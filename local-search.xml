<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础（下）</title>
    <link href="/2022/11/14/java%E5%9F%BA%E7%A1%80(%E4%B8%8B)/"/>
    <url>/2022/11/14/java%E5%9F%BA%E7%A1%80(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础-下"><a href="#java基础-下" class="headerlink" title="java基础 下"></a>java基础 下</h1><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><p>用来记录程序运行过程中的信息，并可以永久保存</p><p>日志系统的优势：</p><ul><li>可以将系统执行的信息选择性记录到指定位置 控制台、文件、数据库</li><li>可以随时开关的形式控制是否记录日志，无序修改代码</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>日志规范：</p><p>一些接口，提供日志的实现框架设计标准</p><p>日志框架：</p><p>第三方已经做好的日志实现代码</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220913134922577.png" alt="image-20220913134922577"></p><p>日志实现框架有哪些？</p><ul><li>Log4j</li><li>Logback</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220913150641560.png" alt="image-20220913150641560"></p><h2 id="日志输出格式"><a href="#日志输出格式" class="headerlink" title="日志输出格式"></a>日志输出格式</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;appender&gt;</span><br></code></pre></td></tr></table></figure><p>appender标签可以设置输出位置和日志信息的详细格式</p><p>通常可以设置两个日志输出设置：一个是控制台，一个是系统文件</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220913154632417.png" alt="image-20220913154632417"></p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>可以控制输出级别来控制哪些日志信息输出或者不输出</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220913160557808.png" alt="image-20220913160557808"></p><h2 id="File流"><a href="#File流" class="headerlink" title="File流"></a>File流</h2><p>定位文件：</p><p>File 类可以定义文件：进行删除，获取本身信息等操作</p><p>但是不能读写文件内容</p><p>读写文件数据：</p><p>IO流技术可以对硬盘中的文件进行读写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.md&quot;</span>);<br>System.out.println(f.isFile());<br>System.out.println(f.length());<br><span class="hljs-comment">//支持绝对路径，也支持相对路径</span><br><br><span class="hljs-comment">//FIle类常用方法</span><br>System.out.println(f.getAbsoluteFile());<br>System.out.println(f.getPath());<br>System.out.println(f.getName());<br>System.out.println(f.lastModified());<br><span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> f.lastModified();<br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(time));<br>System.out.println(f.isDirectory());<span class="hljs-comment">//是否是文件夹</span><br></code></pre></td></tr></table></figure><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;ricky.md&quot;</span>);<br>f1.createNewFile();<br><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./zhaoxianrui&quot;</span>);<br>f2.mkdir();<br><br><br></code></pre></td></tr></table></figure><h3 id="File类删除文件功能"><a href="#File类删除文件功能" class="headerlink" title="File类删除文件功能"></a>File类删除文件功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">f2.delete(); <span class="hljs-comment">//删除</span><br></code></pre></td></tr></table></figure><h3 id="File遍历功能"><a href="#File遍历功能" class="headerlink" title="File遍历功能"></a>File遍历功能</h3><ul><li>当调用者不存在时候，返回null</li><li>当调用者是一个文件的时候，返回null</li><li>当调用者是一个空文件夹的时候，返回一个长度为0的数组</li><li>当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在FIle数组中返回</li><li>当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在FIle数组中返回，包含隐藏内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历文件夹</span><br>File[] files = f3.listFiles();<br><span class="hljs-keyword">for</span> (File file : files) &#123;<br>    System.out.println(file);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h3><p>American standard Code for information interchange 美国信息交换标准代码</p><p>ASCII使用1个字节存储一个字符，一个字节是8位，总共可以表示128个字符信息。</p><p>对于英文来说是够用的</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220914154653563.png" alt="image-20220914154653563"></p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>windows系统默认的码表，兼容ASCII ，包含了几万个汉字，并且支持繁体汉字以及部分日韩文字</p><p>GBK是中国的码表，一个中文以两个字节形式存储，但不包含世界上所有国家的文字。</p><h3 id="Unicode码表"><a href="#Unicode码表" class="headerlink" title="Unicode码表"></a>Unicode码表</h3><p>统一码，是计算机科学领域里面一项业界字符编码标准</p><p>容纳世界上大多数国家所有常见的文字和符号。</p><p>由于UniCode会先通过UTF-8 ，UTF-16， UTF-32  的编码成二进制后再存储到计算机，其中最为常见的是UTF-8</p><p>注意：</p><ul><li>Unicode是万国码，UTF-8编码一个中文一般以3个字节的形式存储。</li><li>UTF-8也要兼容ASCII编码表</li><li>技术人员都应使用UTF-8的字符集编码</li><li>编码前和编码后的字符集需要一致，否则会出现中文乱码。</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220914155516444.png" alt="image-20220914155516444"></p><ul><li>英文和数字在任何国家的字符集中都占一个字节</li><li>GBK字符中，一个中文字符占2个字节</li><li>UTF-8编码中，一个中文占3个字节</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220914160346319.png" alt="image-20220914160346319"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编码，把文字转换为字节</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;赵Ricky&quot;</span>;<br><span class="hljs-type">byte</span>[] bytes = name.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>);<br>System.out.println(bytes.length);<br>System.out.println(Arrays.toString(bytes));<br><br><span class="hljs-comment">//解码，把字节转化为文字</span><br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes,<span class="hljs-string">&quot;GBK&quot;</span>);<br>System.out.println(rs);<br></code></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>用来读写操作</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220914160505511.png" alt="image-20220914160505511"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>字节输入流：以内存为基准，来自磁盘&#x2F;网络中的数据以字节的形式读入到内存中的流称为字节输入流</li><li>字节输出流：以内存为基准，把内存中的数据以以字节的形式写出到磁盘或者网络中去的流称为字节输出流</li><li>字符输入流：以内存为基准，来自磁盘&#x2F;网络中的数据以字符的形式读入到内存中的流称为字符输入流</li><li>字节输出流：以内存为基准，把内存中的数据以以字符的形式写出到磁盘或者网络中去的流称为字符输出流</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220914163059761.png" alt="image-20220914163059761"></p><h4 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">fim</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ricky.md&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span>  <span class="hljs-title class_">byte</span>[<span class="hljs-number">6</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> fim.read(buffer);<br><span class="hljs-comment">//读取多少，倒出多少</span><br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,len);<br>System.out.println(<span class="hljs-string">&quot;读了个字节&quot;</span>+len);<br>System.out.println(rs);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">fim</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ricky.md&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span>  <span class="hljs-title class_">byte</span>[<span class="hljs-number">6</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len = fim.read(buffer))!=-<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//读取多少，倒出多少</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,len);<br>    System.out.println(<span class="hljs-string">&quot;读了个字节&quot;</span>+len);<br>    System.out.println(rs);<br>&#125;<br></code></pre></td></tr></table></figure><p>文件字节输入流，每次读取一个字节数组的api是哪一个？<br>read(byte [] buffer)</p><p>每次读取一个字节数组存在什么问题？</p><ul><li><p>读取性能得到提升</p></li><li><p>读取中文字符输出无法避免乱码问题</p></li><li></li></ul><p>如何使用字节输入流读取中文内容不乱码？</p><ul><li>定义一个与文件一样大的字节数组，一次性读取完文件的全部字节</li></ul><p>但是如果文件过大，会溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;ricky.md&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f);<br><br><span class="hljs-type">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> is.read(buffer);<br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,len));<br></code></pre></td></tr></table></figure><h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;ricky.md&quot;</span>);<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file,<span class="hljs-literal">true</span>);<span class="hljs-comment">//如果不添加第二个参数为true，则会覆盖之前的文件内容</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;瓯海祥&quot;</span>;<br><span class="hljs-type">byte</span> [] b = name.getBytes(StandardCharsets.UTF_8);<br><br>os.write(b);<br>os.write(<span class="hljs-string">&quot;\r\n&quot;</span>)<span class="hljs-comment">//换行</span><br>os.flush();<span class="hljs-comment">//刷新，刷新后流可以继续使用</span><br>os.close();<span class="hljs-comment">//释放资源，</span><br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220914184636206.png" alt="image-20220914184636206"></p><p>- </p><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>字节流适合做一切文件的拷贝吗？</p><p>任何文件的底层都是字节，拷贝是一字不漏的转移字节，只要前后有文件格式，编码一致没有任何问题。</p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>finally 在异常处理时提供finally块来来执行所有清除操作。比如IO流中的释放资源</p><p>特点：被finally控制的语句最终一定会执行，除非JVM退出</p><p>异常处理标准格式： try catch finally </p><h4 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h4><p>字节流读取中可能会存在什么问题？<br>会乱码。或者内存溢出。</p><p>FileReader  文件字符输入流</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220915163658384.png" alt="image-20220915163658384"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220915163740014.png" alt="image-20220915163740014"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;ricky.md&quot;</span>);<br><span class="hljs-type">char</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len=fr.read(buffer))!=-<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,len);<br>    System.out.println(rs);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Writer</span> <span class="hljs-variable">wr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;ricky3.md&quot;</span>,<span class="hljs-literal">true</span>);<br>wr.write(<span class="hljs-string">&quot;赵献瑞&quot;</span>.toCharArray());<br>wr.flush();<br>wr.close();<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220915164918209.png" alt="image-20220915164918209"></p><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>读写性能更加高效</p><ul><li>缓冲流也称为高效流，或者高级流，之前学习的流为原始流</li><li>作用：自带缓冲区，可以提高原始字节流，字符流读写数据的性能。</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220915184914648.png" alt="image-20220915184914648"></p><p>缓冲流自带缓冲区。可以提高原始字节流，字符流写数据的性能。</p><h3 id="缓冲字节输入输出流"><a href="#缓冲字节输入输出流" class="headerlink" title="缓冲字节输入输出流"></a>缓冲字节输入输出流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;doge2.jpg&quot;</span>);<br><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(is);<br><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ricky2.jpg&quot;</span>);<br><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(os);<br></code></pre></td></tr></table></figure><h3 id="字符缓冲输入输出流"><a href="#字符缓冲输入输出流" class="headerlink" title="字符缓冲输入输出流"></a>字符缓冲输入输出流</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220916140342434.png" alt="image-20220916140342434"></p><h4 id="读取中文最优方案"><a href="#读取中文最优方案" class="headerlink" title="读取中文最优方案"></a>读取中文最优方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用缓冲字符输入输出流来提高性能，新增了按行读取方法</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;ricky.md&quot;</span>);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br>String line;<br><span class="hljs-keyword">while</span> ((line = br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>    System.out.println(line);<br>&#125;<br></code></pre></td></tr></table></figure><p>字符缓冲刘为什么提高了操作数据的性能？</p><ul><li>字符缓冲流自带了8K的缓冲区</li><li>可以提高原始字符读写数据的性能</li></ul><p>性能提升了，多了newLine()方法。</p><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>之前我们使用字符流读取中文是否有乱码？</p><ul><li>没有，因为代码编码和文件编码都是UTF-8</li></ul><p>字符流直接读取文本内容：</p><ul><li>必须文件和代码编码一致才会不乱吗</li><li>如果不一致，则会乱码</li></ul><h3 id="字符输入转换流"><a href="#字符输入转换流" class="headerlink" title="字符输入转换流"></a>字符输入转换流</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220916144829779.png" alt="image-20220916144829779"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ricky3.txt&quot;</span>);<br><span class="hljs-type">Reader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is,<span class="hljs-string">&quot;GBK&quot;</span>);<br><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>String lien;<br><span class="hljs-keyword">while</span>((lien = bf.readLine())!= <span class="hljs-literal">null</span>)&#123;<br>    System.out.println(lien);<br>&#125;<br></code></pre></td></tr></table></figure><p>字符输入转换流解决了不同编码乱码问题。</p><h3 id="字符输出转换流"><a href="#字符输出转换流" class="headerlink" title="字符输出转换流"></a>字符输出转换流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ricky4.txt&quot;</span>);<br><span class="hljs-type">Writer</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(os,<span class="hljs-string">&quot;GBK&quot;</span>);<br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(osw);<br><br>bw.write(<span class="hljs-string">&quot;我爱中国&quot;</span>);<br>bw.close();<br></code></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>作用：以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化。</p><p>使用到的流是对象字节输入流：ObjectOutputStream</p><p><strong>注意：对象如果要序列化，必须要实现Serializable接口</strong></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220916150743083.png" alt="image-20220916150743083"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对象如果要序列化，必须要实现Serializable接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;s1&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;student.txt&quot;</span>);<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(os);<br><br>        oos.writeObject(s);<br>        oos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;student.txt&quot;</span>);<br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span> (is);<br><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) ois.readObject();<br><br>System.out.println(s);<br></code></pre></td></tr></table></figure><h3 id="修饰符-transient"><a href="#修饰符-transient" class="headerlink" title="修饰符  transient"></a>修饰符  transient</h3><p>如果不想将某个成员变量进行序列化（比如密码），可以在前面加上修饰符  transient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String password;<br></code></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>打印流可以实现方便、高效的打印数据到文件中去。</p><p>打印流一般指的是：PrintStream  PrintWriter两个类</p><p>可以实现，打印什么数据就是什么数据，例如打印整数97，写出去就是97</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;ps.txt&quot;</span>);<br>ps.println(<span class="hljs-number">87</span>);<br>ps.println(<span class="hljs-string">&quot;dfs&quot;</span>);<br>ps.println(<span class="hljs-string">&#x27;f&#x27;</span>);<br>ps.println(<span class="hljs-string">&quot;打印输出流&quot;</span>);<br>ps.close();<br></code></pre></td></tr></table></figure><p>打印功能上PrintStream  PrintWriter 没有什么区别。</p><p>PrintStream 属于字节输出流  继承自OutputStream 支持写字节数据的方法</p><p>PrintWriter 属于字符输出流  继承自Writer 支持写字符数据的方法。</p><h3 id="输出语句重定向"><a href="#输出语句重定向" class="headerlink" title="输出语句重定向"></a>输出语句重定向</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220916160249611.png" alt="image-20220916160249611"></p><p>控制台输出到文件中。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>其实就是一个Map集合，但是一般不当集合用，因为HashMap更好用</p><p>Properties核心作用</p><p>代表一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。。</p><p>属性文件：后缀是.properties 结尾的文件，里面的内容都是key&#x3D;value 后续做系统配置信息的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span>  <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.put(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>properties.setProperty(<span class="hljs-string">&quot;Fds&quot;</span>,<span class="hljs-string">&quot;fdsf&quot;</span>);<br>properties.setProperty(<span class="hljs-string">&quot;赵宪锐&quot;</span>,<span class="hljs-string">&quot;fsdfsdf&quot;</span>);<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数一：输出流管道</span><br><span class="hljs-comment"> * 参数二：保存注释</span><br><span class="hljs-comment"> */</span><br>properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;pro.properties&quot;</span>),<span class="hljs-string">&quot;注释&quot;</span>);<br></code></pre></td></tr></table></figure><p>加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><br>p.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;pro.properties&quot;</span>));<br>System.out.println(p);<br>System.out.println(p.getProperty(<span class="hljs-string">&quot;赵宪锐&quot;</span>));<br>System.out.println(p.getProperty(<span class="hljs-string">&quot;123&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="IO流框架"><a href="#IO流框架" class="headerlink" title="IO流框架"></a>IO流框架</h2><p>commons-io</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220916161827719.png" alt="image-20220916161827719"></p><p>commons-io是一款处理io流的工具，封装了很多处理io流和文件的方法，可以大大简化我们处理io流和操作文件的代码。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><h4 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h4><p>继承Thread类</p><ol><li>定义一个子类MyThread 继承 Thread  重写run方法</li><li>创建MyThread对象</li><li>调用线程对象的start方法启动线程。（最后还是调用run方法）</li></ol><p>缺点：</p><p>线程类已经继承了Thread，无法继承其他类，不利于扩展</p><p><strong>为什么调用start？</strong></p><p>这样会告诉cpu以线程的方式启动</p><p>要把主线程任务放在子线程之后</p><p>优缺点是什么？</p><ul><li><p>优点：编码简单</p></li><li><p>缺点：线程类已经继承了Thread，无法继承其他类，不利于扩展</p></li></ul><h4 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h4><p>实现Runnable接口</p><ol><li>定义一个线程任务类：MyRunnable实现Runnable接口，重写run方法</li><li>创建MyRunnable任务对象</li><li>把MyRunnable任务对象交给Thread处理</li><li>调用线程对象start方法启动线程</li></ol><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917132954025.png" alt="image-20220917132954025"></p><p>优缺点：</p><ul><li>优点：线程人物类只是实现接口，可以继续继承类和实现接口，扩展性强</li><li>缺点：编程多一层包装对象，如果线程有执行结果是不能返回的。</li></ul><p><strong>匿名内部类写法</strong></p><ul><li>可以创建Runnable的匿名内部类对象</li><li>交给Thread处理</li><li>调用线程对象的start启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">50</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程三&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">50</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程二&quot;</span>+i);<br>&#125;&#125;);<br><br>t2.start();<br>t.start();<br></code></pre></td></tr></table></figure><h4 id="方式3：（Callable接口）"><a href="#方式3：（Callable接口）" class="headerlink" title="方式3：（Callable接口）"></a>方式3：（Callable接口）</h4><p>jdk5新增</p><p>前两种方式都存在一个问题</p><ul><li>他们重写的run方法不能直接返回结果</li><li>不适合需要返回线程结果的业务场景</li></ul><ol><li>得到任务对象<ol><li>定义类实现Callable接口，重写call方法，封装成要做的事情</li><li>用FutureTask把Callable对象封装成线程任务对象</li></ol></li><li>把线程任务对象交给Thread处理</li><li>调用Thread的start方法启动线程</li><li>线程执行完毕之后，通过FutureTak的get方法获取任务执行的结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadCall</span>(<span class="hljs-number">10</span>);<br>FutureTask&lt;String&gt; ft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft);<br>t.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    System.out.println(i);<br>&#125;<br><br><span class="hljs-comment">//如果ft任务没有跑完，这里的get会等待，直到线程跑完提取结果</span><br>System.out.println(ft.get());<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917140941008.png" alt="image-20220917140941008"></p><p>优缺点：</p><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强</p><p>​可以在线程执行完毕后获取线程返回的结果</p><p>缺点：编程相对复杂</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917141116554.png" alt="image-20220917141116554"></p><h3 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h3><p>getName、setName、currentThread</p><p>至于 yield  join  interrupt 不推荐的方法stop 守护线程 线程优先级等线程控制的方法，在开发中用到的很少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br><br>t2.setName(<span class="hljs-string">&quot;3号&quot;</span>);<br>System.out.println(t2.getName());<br><span class="hljs-comment">//得到当前线程</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">ct</span> <span class="hljs-operator">=</span> Thread.currentThread();<br></code></pre></td></tr></table></figure><p>也可以在创建线程的时候，给入名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Thread类的线程休眠方法"><a href="#Thread类的线程休眠方法" class="headerlink" title="Thread类的线程休眠方法"></a>Thread类的线程休眠方法</h4><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917142440926.png" alt="image-20220917142440926"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    System.out.println(<span class="hljs-string">&quot;主线程输出&quot;</span>+i);<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">//休眠3秒钟</span><br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程安全、线程同步"><a href="#线程安全、线程同步" class="headerlink" title="线程安全、线程同步"></a>线程安全、线程同步</h3><p>多个线程同时操作一个共享资源的时候，可能会出现业务安全问题。称为线程安全问题</p><ul><li>存在多线程并发</li><li>同时访问共享资源</li><li>存在修改共享资源</li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>让多个线程先后依次访问共享资源</p><ul><li>加锁：把共享资源进行上锁，每次智能一个线程进入访问完毕之后解锁，然后其他线程才能进来</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917145124305.png" alt="image-20220917145124305"></p><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>把出现线程安全问题的代码上锁</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917150308029.png" alt="image-20220917150308029"></p><p>锁对象的要求</p><ul><li>理论上 锁对象只要对于当前同时执行的线程来说是同一个对象即可。</li></ul><p><strong>锁对象用任意唯一的对象好不好？</strong></p><p><strong>不好，会影响其他无关线程的执行</strong></p><p>规范：</p><ul><li>建议使用共享资源作为锁对象</li><li>对于实例方法建议使用this作为锁对象</li><li>对于静态方法，建议使用字节码(类名.calss) 对象作为锁对象</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917151312876.png" alt="image-20220917151312876"></p><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>把出现线程安全问题的核心方法给上锁</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917154319536.png" alt="image-20220917154319536"></p><p>底层原理：</p><ul><li>底层也是有隐式锁对象，只是锁的范围是整个方法代码</li><li>如果方法是实例方法，同步方法默认使用this作为锁对象。但是代码要高度面向对象</li><li>如果方法是静态方法：同步方法默认用类名.class作为锁对象</li></ul><p>是同步代码块好还是同步方法好？</p><ul><li>同步代码块锁的范围更小，同步方法锁的范围更大</li></ul><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><ul><li>为了更清晰表达如何加锁和释放锁，jdk5之后提供了一个新的锁对象，lock。更加灵活方便</li><li>Lock实现提供比使用synchronize方法和语句可以获得更广泛的锁定操作</li><li>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock 来构建Lock对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//final修饰后，唯一且不可替换的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917155559060.png" alt="image-20220917155559060"></p><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>所谓线程通信就是线程间相互发送数据，线程通信通常通过共享一个数据的方式实现。</p><p>线程间会根据共享数据的情况决定自己该怎么做。</p><p>线程通信常见模型：</p><ul><li>生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费数据</li><li>要求：生产者线程生产完数据后，唤醒消费者，然后等待自己；消费者消费完数据后，唤醒生产者，然后等待自己。</li></ul><p><strong>线程通信前提：线程通信通常是在多个线程操作同一个共享资源的时候需要进行通信，且要保证线程安全。</strong></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917213224384.png" alt="image-20220917213224384"></p><p>上述方法应当使用当前同步锁对象进行调用。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>线程池就是一个可以复用线程的技术</li></ul><p>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，<strong>而创建新线程的开销是很大的</strong>，这样会严重影响系统的性能。</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917214712267.png" alt="image-20220917214712267"></p><p>JDK5提供了 线程池接口 ExecutorService  </p><ul><li>方式一：使用ExecutorService的实现类ThreadPoolExecutor 自创一个线程池对象</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917214945456.png" alt="image-20220917214945456"></p><ul><li>方拾二：使用Exectors线程池的工具类调用方法返回不同特点的线程池对象</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220917215353565.png" alt="image-20220917215353565"></p><h4 id="临时线程什么时候创建？"><a href="#临时线程什么时候创建？" class="headerlink" title="临时线程什么时候创建？"></a>临时线程什么时候创建？</h4><p>新任务提交的时候发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程</p><h3 id="什么时候会开始拒绝服务？"><a href="#什么时候会开始拒绝服务？" class="headerlink" title="什么时候会开始拒绝服务？"></a>什么时候会开始拒绝服务？</h3><p>核心线程和临时线程都在忙，任务队列也满了， 新的任务过来的时候才会开始任务拒绝。</p><h3 id="处理Runnable任务"><a href="#处理Runnable任务" class="headerlink" title="处理Runnable任务"></a>处理Runnable任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<br>        <span class="hljs-number">6</span>, TimeUnit.SECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5</span>),<br>        Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><br><span class="hljs-comment">//给任务线程池处理</span><br><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>pool.execute(target);<br>pool.execute(target);<br>pool.execute(target);<br><br><span class="hljs-comment">//关闭线程（并发中一般不会使用）</span><br>pool.shutdownNow(); <span class="hljs-comment">//立即关闭，即使任务</span><br>pool.shutdown();<span class="hljs-comment">//会等全部任务执行完毕之后再关闭</span><br><br><br></code></pre></td></tr></table></figure><h3 id="处理Callable任务"><a href="#处理Callable任务" class="headerlink" title="处理Callable任务"></a>处理Callable任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<br>        <span class="hljs-number">6</span>, TimeUnit.SECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5</span>),<br>        Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><br><br><span class="hljs-comment">//给任务线程池处理</span><br><br>Future&lt;String&gt; f1 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableDemo</span>(<span class="hljs-number">100</span>));<br><br>System.out.println(f1.get());<br></code></pre></td></tr></table></figure><h3 id="Exectors工具类"><a href="#Exectors工具类" class="headerlink" title="Exectors工具类"></a>Exectors工具类</h3><p>线程池的工具类通过调用方法返回不同类型的线程池对象</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220918132515644.png" alt="image-20220918132515644"></p><p>大型并发系统环境中使用executors如果不注意可能会出现系统风险</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220918132950516.png" alt="image-20220918132950516"></p><h4 id="阿里巴巴规约"><a href="#阿里巴巴规约" class="headerlink" title="阿里巴巴规约"></a>阿里巴巴规约</h4><p>建议自己new 线程池对象，不允许使用Executors去创建</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220918133156501.png" alt="image-20220918133156501"></p><p>Executors不适合做大型互联网场景的线程池方案</p><h3 id="定时器、线程状态"><a href="#定时器、线程状态" class="headerlink" title="定时器、线程状态"></a>定时器、线程状态</h3><ul><li>定时器是一种控制任务延时调用，或者周期调动技术</li><li>作用：闹钟、定时发送邮件</li></ul><p>方式：</p><ul><li>方式一：Timer</li><li>方式二：ScheduledExecutorService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建Timer定时器</span><br><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br><span class="hljs-comment">//调用方法，处理定时任务</span><br>timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行一次&quot;</span>);<br>    &#125;<br>&#125;,<span class="hljs-number">3000</span>,<span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><p>Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入</p><p>可能因为其中某个任务的异常使Timer线程死掉，从而影响后续任务执行。</p><h4 id="ScheduledExecutorService定时器"><a href="#ScheduledExecutorService定时器" class="headerlink" title="ScheduledExecutorService定时器"></a>ScheduledExecutorService定时器</h4><p>ScheduledExecutorService是jdk1.5中引入的并发包，目的是为了弥补Timer的缺陷。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//开启定时任务</span><br>pool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行输出AAA&quot;</span>);<br>    &#125;<br>&#125;,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>优点：</p><p>基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</p><p>其中某一个任务失败了，不影响其他的任务。</p><h2 id="并发并行"><a href="#并发并行" class="headerlink" title="并发并行"></a>并发并行</h2><p>正在运行的程序是一个独立的进程，线程是属于进程的，多个线程其实是并发与并行同时进行的。</p><p>并发的理解：</p><ul><li>CPU同时处理线程的数量有限</li><li>CPU会轮询为系统的每一个线程服务，由于CPU切换速度很快，给我们感觉这些现线程是同时执行，这就是并发。</li></ul><p>并行：</p><p>在同一时刻，同时有多个线程在被CPU处理并执行</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul><li>线程的状态：也就是线程从生到死的过程，以及中间经历的各种状态及状态转换</li><li>理解线程的状态有利于提升并发编程的理解能力</li></ul><p>java总共定义了6种状态</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220918141343895.png" alt="image-20220918141343895"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220918141642231.png" alt="image-20220918141642231"></p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>常见通信模式：CS(Cliend Server)、 BS (Browser Service)</p><p>三要素：<br>IP地址：在网络中的地址，是唯一标识</p><p>端口：应用程序在设备中唯一标识</p><p>协议：数据在网络中传输的规则， 常见的协议有UDP和TCp</p><p>IPV6 ：128位（16字节），号称可以为地球每一粒沙子编号。</p><p>IPV6 ：分成8个整数，每个整数用四个十六进制位标识，数之间用冒号分开</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220920162700346.png" alt="image-20220920162700346"></p><p>IP命令：</p><ul><li>ipconfig</li><li>ping IP</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220920164147971.png" alt="image-20220920164147971"></p><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220920164335999.png" alt="image-20220920164335999"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> InetAddress.getLoopbackAddress();<br>System.out.println(ip.getHostAddress());<br><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip2</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br>System.out.println(ip2.getHostAddress());<br><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip3</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;110.242.68.4&quot;</span>);<br>System.out.println(ip3.getHostName());<br><br><span class="hljs-comment">//ping 判断与该IP地址对象是否互通</span><br>System.out.println(ip3.isReachable(<span class="hljs-number">5000</span>));<br></code></pre></td></tr></table></figure><h2 id="端口号："><a href="#端口号：" class="headerlink" title="端口号："></a>端口号：</h2><p>标识正在计算机设备上运行的程序，被规定为一个16位的二进制，范围是0~65535</p><ul><li>周知端口： 0~1023    被预先定义的知名应用占用（HTTP: 80 ,FTP 21）</li><li>注册端口： 1024~49151  分配给用户进程或某些应用程序，（Tomcat :8080 ， Mysql:3306）</li><li>动态端口： 49152~65535 之所以被称为动态端口，是因为它一般不固定分配某种进程，而是东塔分配</li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>连接和通信数据的规则被称为网络通信协议</p><ul><li>OSI参考模型：世界互联网协议标准，全球通信规范，由于此模型过于标准化，未能在因特网进行广泛推广</li><li>TCP&#x2F;IP 参考模型：事实上的国际标准</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220920170022678.png" alt="image-20220920170022678"></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>可靠通信协议</p><p>三次握手建立链接</p><p>在连接中可进行大量数据的传输</p><p>连接，发送数据需要确认，传输完毕后还需要释放连接，通信效率低</p><p>场景：文件下载，金融数据</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>无连接。不可靠传输</p><p>将数据源IP、目的地址和端口封装成数据包，不需要建立连接</p><p>每个数据包大小限制在64KB</p><p>可以广播发送，发送数据结束时无需释放资源，开销小，速度快</p><p>场景：语音通话</p><h3 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h3><p>DatagramSocket 发送端和接收端对象</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220920212129297.png" alt="image-20220920212129297"></p><p>DatagramSocket类成员方法</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220920212112578.png" alt="image-20220920212112578"></p><h3 id="UDP-通信-广播，组播"><a href="#UDP-通信-广播，组播" class="headerlink" title="UDP 通信 广播，组播"></a>UDP 通信 广播，组播</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220921102200233.png" alt="image-20220921102200233"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220921102437649.png" alt="image-20220921102437649"></p><h4 id="MulticastSocket"><a href="#MulticastSocket" class="headerlink" title="MulticastSocket"></a>MulticastSocket</h4><p>组播时，需要在服务端绑定组播IP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MulticastSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulticastSocket</span>(<span class="hljs-number">8888</span>);<br><span class="hljs-comment">//把当前接收端加入到一个组播组中去</span><br>socket.joinGroup(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(InetAddress.getByName(<span class="hljs-string">&quot;224.0.0.1&quot;</span>),<span class="hljs-number">9999</span>),<br>       NetworkInterface.getByInetAddress(InetAddress.getLocalHost()) );<br></code></pre></td></tr></table></figure><h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220921103321768.png" alt="image-20220921103321768"></p><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;服务端开启&quot;</span>);<br><span class="hljs-comment">//注册端口</span><br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">7777</span>);<br><span class="hljs-comment">//接收sockt</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;客户端开启&quot;</span>);<br><span class="hljs-comment">//创建socket管道，请求与服务端连接</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">7777</span>);<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br>ps.println(<span class="hljs-string">&quot;我是TCP客户端，我已经与你对接&quot;</span>);<br>ps.flush();<br></code></pre></td></tr></table></figure><h3 id="TCP多线程"><a href="#TCP多线程" class="headerlink" title="TCP多线程"></a>TCP多线程</h3><p>服务端只有一个线程的情况下，只能与一个客户端进行通信</p><p>使用多线程处理多个客户端请求： 创建线程类ServerReaderThread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">//接收sockt，交给独立的子线程处理</span><br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>    System.out.println(socket.getRemoteSocketAddress()+<span class="hljs-string">&quot;他来了&quot;</span>);<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池处理"><a href="#线程池处理" class="headerlink" title="线程池处理"></a>线程池处理</h3><p>引入线程池，不会导致系统资源耗尽的风险</p><p>优点：</p><ul><li>服务端可以复用线程处理多个客户端，可以避免系统瘫痪</li><li>适合客户端通信时长较短的场景</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220921161116581.png" alt="image-20220921161116581"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>, TimeUnit.SECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>),<br>                Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br></code></pre></td></tr></table></figure><p>如果队列满了，且核心线程和临时线程都在忙，就会拒绝下一个请求</p><h2 id="TCP通信实战——即时通信"><a href="#TCP通信实战——即时通信" class="headerlink" title="TCP通信实战——即时通信"></a>TCP通信实战——即时通信</h2><p>端口转发</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220921163051483.png" alt="image-20220921163051483"></p><h2 id="BS开发"><a href="#BS开发" class="headerlink" title="BS开发"></a>BS开发</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220921165657840.png" alt="image-20220921165657840"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220921165837432.png" alt="image-20220921165837432"></p><h1 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h1><p>针对最小功能单元编写测试代码。java程序最小的功能单元是方法</p><p>目前测试方法存在问题：</p><ul><li>只有一个main方法，如果一个方法失败，其他方法测试会受到影响</li><li>无法得到测试结果报告，需要程序员自己去观察测试是否成功</li><li>无法实现自动化测试</li></ul><p>Junit优点</p><ul><li>junit可以灵活选择执行哪些测试方法，可以一键执行全部测试方法</li><li>junit可以生成全部方法的测试报告</li><li>单元测试中的某个方法测试失败了，不会影响其他测试方法的测试</li></ul><p>编写测试方法：该测试方法必须是公共的无参数无返回值的非静态方法</p><p>在测试方法上使用@Test注解，标注该方法是一个测试方法</p><p>在测试方法中完成被测试方法的逾期正确性测试</p><p>选中测试方法，选择JUnit运行</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922152258579.png" alt="image-20220922152258579"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922152317466.png" alt="image-20220922152317466"></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射对于任何一个class类，在运行的时候都可以直接得到这个类的全部成分</p><p>在运行时，得到这个类的构造器对象，成员对象，方法对象</p><p>这种运行时动态获取类信息以及动态调用类中成分的能力称为java语言的反射机制</p><p>反射的关键：</p><p>第一步都是先得到编译后的class类对象，然后就可以得到calss的全部成分‘</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922153309418.png" alt="image-20220922153309418"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922153500898.png" alt="image-20220922153500898"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.learning.c25_reflect.Account&quot;</span>);<br>System.out.println(c);<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Account.class;<br>System.out.println(c);<br><br><span class="hljs-type">Account</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">100.0</span>);<br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> a.getClass();<br>System.out.println(c2);<br></code></pre></td></tr></table></figure><h2 id="获取构造器对象"><a href="#获取构造器对象" class="headerlink" title="获取构造器对象"></a>获取构造器对象</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922153606288.png" alt="image-20220922153606288"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//公开构造器</span><br><span class="hljs-comment">//Constructor[] con = c.getConstructors();</span><br><span class="hljs-comment">//所有构造器</span><br><span class="hljs-comment">//Constructor[] con = c.getDeclaredConstructors();</span><br><span class="hljs-comment">//获取某个无参数public构造器</span><br><span class="hljs-comment">//Constructor con = c.getConstructor();</span><br><span class="hljs-comment">//获取某个private 无参数构造器</span><br><span class="hljs-comment">//Constructor con = c.getDeclaredConstructor();</span><br><span class="hljs-comment">//获取有参数构造器</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(String.class,<span class="hljs-type">int</span>.class);<br></code></pre></td></tr></table></figure><h2 id="暴力反射"><a href="#暴力反射" class="headerlink" title="暴力反射"></a>暴力反射</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();<br><br><br><span class="hljs-comment">//暴力反射</span><br><span class="hljs-comment">//遇到私有构造器，可以暴力反射</span><br>con.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Account</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (Account)con.newInstance();<br>System.out.println(a);<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922155134814.png" alt="image-20220922155134814"></p><p>反射可以破坏封装性，私有的也可以执行了。</p><h2 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922155243223.png" alt="image-20220922155243223"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Account.class;<br><br>Field[] fields = c.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>    System.out.println(field.getName());<br>&#125;<br></code></pre></td></tr></table></figure><p>获取某个成员变量 并且赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Account.class;<br><br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;money&quot;</span>);<br>System.out.println(field.getName() + <span class="hljs-string">&quot;====&gt;&quot;</span> + field.getType());<br><br>field.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//暴力打开权限</span><br><br><span class="hljs-type">Account</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>field.set(a,<span class="hljs-number">100.0</span>);<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922160339769.png" alt="image-20220922160339769"></p><h2 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Account.class;<br><br>Method[] mwthod = c.getDeclaredMethods();<br><span class="hljs-comment">//遍历全部方法</span><br><span class="hljs-keyword">for</span> (Method method : mwthod) &#123;<br>    System.out.println(method.getName()+ <span class="hljs-string">&quot; &quot;</span> +method.getReturnType()+ <span class="hljs-string">&quot; &quot;</span> + method.getParameterCount() );<br>&#125;<br></code></pre></td></tr></table></figure><p>获取某一个方法</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922161452878.png" alt="image-20220922161452878"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Account.class;<br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>,String.class);<br><br><span class="hljs-comment">//暴力反射</span><br>m2.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Account</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>m.invoke(a);<br>m2.invoke(a,<span class="hljs-string">&quot;狗&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="绕过编译阶段为集合添加数据"><a href="#绕过编译阶段为集合添加数据" class="headerlink" title="绕过编译阶段为集合添加数据"></a>绕过编译阶段为集合添加数据</h2><p>反射是作用在运行时的技术，此时结合的泛型将不能产生约束了，此时是可以为集合存入其他类型数据的</p><p>泛型只是在编译阶段可以约束集合只能操作某种类型的数据，在编译成class文件进入运行阶段的时候，其真实类型都是ArrayList，泛型相当于被擦除了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>System.out.println(list1.getClass());<br>list1.add(<span class="hljs-string">&quot;heima&quot;</span>);<br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> list1.getClass();<br><span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>,Object.class);<br>m.invoke(list1,<span class="hljs-number">2</span>);<br>System.out.println(list1);<br></code></pre></td></tr></table></figure><p>编译成class文件进入运行阶段的时候，泛型会自动擦除</p><h2 id="通用框架的底层原理"><a href="#通用框架的底层原理" class="headerlink" title="通用框架的底层原理"></a>通用框架的底层原理</h2><p>需求：给你任意一个对象，在不清楚对象字段的情况下可以把对象的字段名称和对应值存储到文件中</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>annotation 又称为java标注，是jdk5引入的注释机制</p><p>java语言中的类，构造器，方法，成员变量，参数等都可以被注解进行标注</p><p>例如：junit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922165814609.png" alt="image-20220922165814609"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922170113001.png" alt="image-20220922170113001"></p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>注解注解的注解</p><p>元注解有两个：</p><p>@Target 约束自定义注解只能在哪个地方使用</p><p>@Retention 申明注解的生命周期  （约束自定义注解的存活范围）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-comment">//只能注解方法</span><br><br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922203827512.png" alt="image-20220922203827512"></p><h2 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h2><p>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容</p><p><strong>与注解解析相关的接口</strong></p><ul><li>Annotation 注解的顶级接口 注解都是Annotation类型的对象</li><li>AnnotatedElement 该接口定义了与注解解析相关的解析方法</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922204322631.png" alt="image-20220922204322631"></p><ul><li>所有的类成分Class，Method，Field，Constructor 都实现了AnnotatedElement接口，他们都拥有解析注解的能力。</li></ul><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>代理：某些场景下，对象会找一个代理对象，来辅助自己完成一些工作。</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922212022164.png" alt="image-20220922212022164"></p><p>如何创建代理对象：</p><ul><li>java中代理的代表是 jaca.lang.reflect.Proxy</li><li>Proxy提供了静态方法，用于为对象产生一个代理对象返回。</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922213350576.png" alt="image-20220922213350576"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922213520100.png" alt="image-20220922213520100"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220922213623390.png" alt="image-20220922213623390"></p><p>优点：</p><ul><li>可以在不改变方法源码的情况下，实现方法功能的增强，提高了代码复用</li><li>简化了编程工作，提高工作效率， 同时提高了软件系统的可扩展性</li><li>可以被代理对象的所有方法做代理</li><li>非常灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理</li></ul><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>extensible Markup language 可扩展标记语言的缩写。</p><p>一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储结构。</p><ul><li>纯文本，默认使用UTF-8 可嵌套</li><li>使用场景：经常被当成消息<strong>进行网络传输，或者作为配置文件用于存储系统的信息。</strong></li></ul><p><img src="C:\Users\赵宪锐\AppData\Roaming\Typora\typora-user-images\image-20220926143602895.png" alt="image-20220926143602895"></p><h2 id="xml文档约束"><a href="#xml文档约束" class="headerlink" title="xml文档约束"></a>xml文档约束</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926143739679.png" alt="image-20220926143739679"></p><p>文档约束：用来限定xml文件中的标签以及属性应该怎么写。</p><h3 id="DTD文档约束"><a href="#DTD文档约束" class="headerlink" title="DTD文档约束"></a>DTD文档约束</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926144002554.png" alt="image-20220926144002554"></p><h3 id="schema约束"><a href="#schema约束" class="headerlink" title="schema约束"></a>schema约束</h3><p>可以约束具体的数据类型，约束能力更加强大。</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926144305518.png" alt="image-20220926144305518"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926144346896.png" alt="image-20220926144346896"></p><h2 id="XML解析技术"><a href="#XML解析技术" class="headerlink" title="XML解析技术"></a>XML解析技术</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926144823993.png" alt="image-20220926144823993"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926145325748.png" alt="image-20220926145325748"></p><p>Document对象：整个XML文档</p><p>Element对象：标签</p><p>Attribute对象：属性</p><p>Text对象：文本内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">//创建一个dmo4j的解析器对象，代表了dom4j框架</span><br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">sax</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-comment">//把xml文件加载到内存中成为一个document文档对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">dc</span> <span class="hljs-operator">=</span> sax.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;demo.xml&quot;</span>));<span class="hljs-comment">//通过模块名去定位</span><br><br>        <span class="hljs-comment">//直接从/src下寻找文件</span><br><span class="hljs-comment">//        InputStream is = demo.class.getResourceAsStream(&quot;/demo.xml&quot;);</span><br><span class="hljs-comment">//        Document dc = sax.read(is);</span><br><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> dc.getRootElement();<br>        System.out.println(root.getName());<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926150933405.png" alt="image-20220926150933405"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//root下所有元素</span><br>List&lt;Element&gt; sonEles = root.elements();<br><br><span class="hljs-comment">//取某个子元素</span><br><span class="hljs-type">Element</span> <span class="hljs-variable">use</span> <span class="hljs-operator">=</span> root.element(<span class="hljs-string">&quot;dependency&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="XML检索技术"><a href="#XML检索技术" class="headerlink" title="XML检索技术"></a>XML检索技术</h2><p>检索文件里是否有某些数据</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926174208688.png" alt="image-20220926174208688"></p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>很多业务场景下提供不直接new的方式创建类对象</p><p>作用：</p><p>工厂的方法可以封装对象的创建细节，比如：为该对象进行加工数据标注</p><p>可以实现类与类之间的解耦操作（核心思想）</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>创建一个新类，包装原始类，从而在新类中提升原来类的性能</p><p>作用：</p><p>装饰模式指的是不改变原始类的基础上，动态扩展一个类的功能。</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220926175913037.png" alt="image-20220926175913037"></p>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础（上）</title>
    <link href="/2022/11/13/java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/11/13/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>扫描器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入your Name&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> sc.next();<br></code></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合非常适合做元素个数不确定，且要进行增删操作的业务场景</p><p>提供了许多丰富的功能。</p><ul><li>数组定义后类型确定，长度固定</li><li>集合类型可以不固定，大小是可变的</li></ul><p>泛型</p><p>ArrayList<E> 其实就是一个泛型类，可以在编译阶段约束集合对象只能操作某一种类型的数据</p><p>举例：</p><ul><li>ArrayList<String> 此集合只能操作字符串类型的元素</li><li>ArrayList<Integer> 此集合只能操作整数类型的元素</li></ul><p>集合中只能存储引用类型，不支持基本数据类型</p><p>List、Queue、Set、Map</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>ArrayList:</p><p>Vector:</p><p>LinkedList:</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set的核心特性是独一无二的，适用于无序且值不相等的元素。</p><p><strong>HashSet：HashMap实现，无序</strong></p><p>存放的散列值，按照元素的散列值来存取元素。元素的散列值通过元素的hashCode方法计算得到，HashSet首先判断两个元素散列值是否相等，如果散列值相等，则通过equals方法比较，如果equal方法返回的结果也为true，HashSet就将其视为同一个元素；</p><p><strong>TreeSet：二叉树实现</strong></p><p>Treeset基于二叉树的原理对新添加的对象按照指定的顺序，每添加一个对象都会进行排序，并将对象插入二叉树指定的位置。</p><p><strong>LinkHashSet：继承HashSet， HashMap实现数据存储，双向链表记录顺序</strong></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong>HashMap：数组+链表存储数据，线程不安全</strong></p><p><strong>ConcurrentHashMap：分段锁实现，线程安全</strong></p><h2 id="数组的内存"><a href="#数组的内存" class="headerlink" title="数组的内存"></a>数组的内存</h2><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220825124453711.png" alt="image-20220825124453711"></p><p>数组变量名中存储的数组在内存中的地址，数组是引用类型。</p><p>数组一旦被定义出来，程序执行过程中，长度类型就固定了。</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>同一个类中，方法名字相同，但是形参列表不同。</p><p>形参列表不同指的是：形参的个数，类型，顺序不同，不关心形参的名称。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>String 被称为不可变字符串类型，对象在创建后不能被更改。</li></ul><p>String不可变字符串的原因</p><p>string变量每次的修改其实都是产生并指向了新的字符串对象</p><p><strong>创建String的两种方式</strong>：1，直接使用“”定义。 2，使用构造器创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接用“”</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;as&quot;</span>;<br><br><span class="hljs-comment">//通过构造器</span><br><span class="hljs-type">char</span>[] chars = &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br><br><span class="hljs-type">byte</span>[] bytes = &#123;<span class="hljs-number">94</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">55</span>,<span class="hljs-number">12</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);<br></code></pre></td></tr></table></figure><p><strong>区别：</strong></p><p>双引号创建的字符串对象，在字符串常量池中存储同一个</p><p>通过new构造器创建的字符串对象，在堆内存中分开存储</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220825191346828.png" alt="image-20220825191346828"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220825191309053.png" alt="image-20220825191309053"></p><p>常见面试题</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220825191549365.png" alt="image-20220825191549365"></p><p>第一个为什么编译器没有优化，因为s2是个变量，编译器无法知道其值。</p><p><strong>String</strong>常用API</p><p>字符串的内容比较不适合用 &#x3D;&#x3D; 比较</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220825192215703.png" alt="image-20220825192215703"></p><p>字符串使用queals方法比较是否相等</p><p>开发中什么时候使用&#x3D;&#x3D;比较</p><ul><li>基本数据类型比较时使用&#x3D;&#x3D;进行比较</li></ul><h2 id="自动拆箱与自动装箱"><a href="#自动拆箱与自动装箱" class="headerlink" title="自动拆箱与自动装箱"></a>自动拆箱与自动装箱</h2><p>自动装箱：就是将基本数据类型自动转换成对应的包装类</p><p>自动拆箱：就是将包装类自动转换为基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure><p><code>Integer i=10</code> 可以替代 <code>Integer i = new Integer(10);</code>，这就是因为 Java 帮我们提供了自动装箱的功能，不需要开发者手动去 new 一个 Integer 对象。</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>Random随机数技术</p><p>Random(n) 默认生成0-(n-1)的随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.random;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">randomnumber</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span>  <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">//0-9的随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">// 1-10的随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nummber3</span> <span class="hljs-operator">=</span>r.nextInt(<span class="hljs-number">27</span>) + <span class="hljs-number">65</span>; <span class="hljs-comment">//65-91的随机数</span><br>        System.out.println(number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JAVABean"><a href="#JAVABean" class="headerlink" title="JAVABean"></a><strong>JAVABean</strong></h2><p>可以成为实体类，其对象可以用于在程序中封装数据</p><p>标准JavaBean须满足如下要求</p><ul><li><strong>成员变量使用private修饰</strong></li><li>提供成员变量对应的set和get方法</li></ul><p>必须 提供一个无参构造器；有参构造器是可以不写的</p><h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><ul><li>static是静态的意思，可以修饰成员变量和成员方法</li><li>static修饰成员变量表示该成员变量只在<strong>内存中存储一份</strong>，可以被共享访问，修改</li></ul><h3 id="成员变量内存机制"><a href="#成员变量内存机制" class="headerlink" title="成员变量内存机制"></a>成员变量内存机制</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220826112527924.png" alt="image-20220826112527924"></p><p>静态成员变量在加载类的时候就会在堆内存的类静态变量去开辟一块内存。</p><p><strong>成员方法的分类</strong>：</p><ul><li>静态成员方法，建议用类名访问，也可以用对象访问</li><li>实例成员方法，无static ，只能用对象触发访问</li></ul><p>场景</p><ul><li>表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明为实例方法</li><li>如果该方法是以执行一个共用功能为目的，则可以申明为静态方法</li></ul><h3 id="成员方法内存机制"><a href="#成员方法内存机制" class="headerlink" title="成员方法内存机制"></a>成员方法内存机制</h3><p>静态方法和类一起加载</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220826113711107.png" alt="image-20220826113711107"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>静态方法只能访问静态的成员，不可以<strong>直接访问</strong>实例成员</li><li>实例方法可以访问静态成员，也可以访问实例成员</li><li>静态方法中是不可以出现this关键字</li></ul><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>类中都是一些静态方法，每个方法都是以完成一个共用的功能为目的，这个类用来给系统开发人员共同使用</p><p>由于工具类里面都是静态方法，直接用类名即可访问，因此，工具类无需创建对象，<strong>建议将工具类的构造器进行私有。</strong></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>概述</p><p>代码块是类的五大成分之一（成员变量，构造器，方法，代码块，内部类），定义在类中的方法外。</p><p>使用{} 括起来的代码被称为代码块</p><p><strong>代码块分为</strong></p><ul><li>静态代码块</li></ul><p>格式 static {}   属于类</p><p>需要通过static关键字修饰，<strong>随着类的加载而加载</strong>，并且自动触发，只执行一次</p><p>使用场景：在类加载的时候做一些<strong>静态数据初始化</strong>的操作，以便后续使用</p><ul><li>构造代码块</li></ul><p>格式：{}  属于对象</p><p>特点：<strong>每次创建对象，调用构造器执行时</strong>，都会执行该代码块中的代码，并且在构造器执行前执行</p><p>使用场景：初始化实例资源</p><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>开发中经常遇到一些问题，一个问题通常有n种解法，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来，称为设计模式</p><p>设计模式有20多种，对应20多种软件开发中遇到的问题。</p><p>单例模式</p><ul><li>可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象</li><li>例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间</li></ul><p><strong>饿汉单例设计模式</strong></p><p>在用类获取对象的时，对象已经提前为你准备好了</p><p>设计步骤：</p><ul><li>定义一个类，<strong>把构造器私有</strong></li><li>定义一个静态变量存储一个对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleinstance</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 恶汉单例设计模式</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 饿汉单例是在获取对象前，对象已经提前准备好了一个，这个对象只能是一个，</span><br><span class="hljs-comment">    * 所定义静态成员变量记住。</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleinstance</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleinstance</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleinstance</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>懒汉单例设计模式</strong></p><ul><li>在真正需要该对象的时候，采取创建一个对象(延迟加载对象)</li></ul><p>步骤：</p><ul><li>定义一个类，把构造器私有化</li><li>定义一个静态变量存储一个对象</li><li>提供一个返回单例对象的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance2</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 懒汉单例设计模式</span><br><span class="hljs-comment">    * */</span><br><br>    <span class="hljs-comment">/*2 定义静态成员变量存储一个对象*/</span><br>    <span class="hljs-comment">/*懒汉单例，要将对象私有化*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleInstance2 instance;<br><br>    <span class="hljs-comment">/*1 构造私有化构造器</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance2</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-comment">/*提供一个方法，对外返回单例对象*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance2</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>允许我们用extend关键字，让一个类和另一个类建立起一种父子关系</li><li>提高代码复用性，减少代码冗余，增强类的功能性拓展</li></ul><p>继承后子类的特点：</p><ul><li>子类继承父类，子类可以得到父类的属性和行为，子类可以使用</li><li>java中子类更强大</li></ul><p>内存情况</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220829143231449.png" alt="image-20220829143231449"></p><p>满足什么样的设计规范：</p><ul><li>子类们相同的特征（共性属性，共性方法），放在父类中</li><li>子类独有的属性和行为应该在定义在子类自己里面</li></ul><h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><ul><li>子类可以继承父类的属性和行为，<strong>但是子类不能继承父类的构造器</strong></li><li>java是单继承模式，一个类只能继承一个直接父类</li><li>java不支持多继承，但是支持多层继承</li><li>java中所有的类都是Object的子类</li></ul><h4 id="子类是否可以继承父类的私有成员？"><a href="#子类是否可以继承父类的私有成员？" class="headerlink" title="子类是否可以继承父类的私有成员？"></a>子类是否可以继承父类的私有成员？</h4><p>可以，只是不能直接访问</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220829144443427.png" alt="image-20220829144443427"></p><h4 id="子类是否可以继承父类的静态成员？"><a href="#子类是否可以继承父类的静态成员？" class="headerlink" title="子类是否可以继承父类的静态成员？"></a>子类是否可以继承父类的静态成员？</h4><p>有争议的知识点</p><ul><li>子类可以直接使用父类的静态成员（共享）</li><li>但是个人认为，子类不能继承父类的静态成员（共享并非继承）</li></ul><p>在子类方法中访问成员（成员变量，成员方法）满足就近原则：</p><ul><li>先子类局部范围找</li><li>然后子类成员范围找</li><li>然后父类成员范围找，如果父类范围没有找到，则报错</li></ul><p>如果子父类中，出现了重名的成员，会有限使用子类的，此时如果一定要在子类中使用父类怎么办？</p><p>可以通过<strong>关键字super</strong>，指定访问父类的成员。</p><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p><strong>子类出现了和父类中一模一样的方法声明</strong>，我们就称子类这个方法是重写的方法。</p><p>可以加注解</p><p>@Override    &#x2F;&#x2F;重写校验注解，加注解后，这个方法必须是正确重写的，这样更安全</p><p>加注解后，代码更优雅，提高程序可读性</p><p>注意: </p><ul><li>重写方法的名词和形参列表必须和被重写的方法一模一样</li><li>私有方法不能被重写</li><li>子类重写父类方法时，访问权限必须大于或者等于父类</li><li>静态方法不能被重写</li></ul><h3 id="继承：构造器"><a href="#继承：构造器" class="headerlink" title="继承：构造器"></a>继承：构造器</h3><p>子类中所有的构造器默认都会先访问父类中无参构造器，再执行自己。</p><p>Why？</p><p>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据</p><p>子类初始化之前，一定要调用父类构造前先完成父类数据空间的初始化。</p><ul><li>子类构造器的第一行语句默认都是: super(), 不写也存在</li></ul><p>super调用父类有参数构造器的作用：</p><ul><li>初始化继承自父类的数据</li></ul><p><strong>如果父类没有无参数构造器，只有有参数构造器，会出现什么现象？</strong></p><p>会报错，因为子类默认是调用父类无参数构造器的。</p><p>一个类中如果自己定义了有参数构造器，默认的无参数构造器就没了，需要自己定义</p><h3 id="this和super的总结"><a href="#this和super的总结" class="headerlink" title="this和super的总结"></a>this和super的总结</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220829225622769.png" alt="image-20220829225622769"></p><p><strong>注意</strong></p><ul><li>子类通过this(..)去调用本类的兄弟构造器，本类兄弟构造器会通过super去手动调用父类的构造器，最终还是会调用父类构造器的。</li><li>this(..) super(….) 都只能放在构造器的第一行，所以二者不能共存在同一个构造器中</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220829230304623.png" alt="image-20220829230304623"></p><h2 id="包，权限修饰"><a href="#包，权限修饰" class="headerlink" title="包，权限修饰"></a>包，权限修饰</h2><p>同一个类中，如果使用不同包下的相同类名，默认只能导入一个，另一个只能使用全名访问</p><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>private —&gt; 缺省 ——&gt;protected ——&gt; public</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831104744394.png" alt="image-20220831104744394"></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final 关键字是最终的意思，可以修饰（类，方法，变量）</p><ul><li>修饰类：表名该类是最终类</li><li>修饰方法：表名该方法是最终方法，<strong>不能被重写</strong></li><li>修饰变量：表名该变量第一次被赋值之后，不能再次被赋值</li></ul><p><strong>注意</strong>：</p><ul><li>final修饰的变量是基本类型：那么变量存储的<strong>数据值</strong>不能改变</li><li>final修饰的变量类型是引用类型，那么变量存储的地址值不能发生改变，但是地址指向得对象内容是可以发生变化的。</li></ul><h2 id="常量，常量在开发中的作用"><a href="#常量，常量在开发中的作用" class="headerlink" title="常量，常量在开发中的作用"></a>常量，常量在开发中的作用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>常量使用了 public static final修饰的成员变量，必须有初始化值，而且执行过程中值不能被改变</p><p>常量的作用和好处：可以用做系统的配置信息，方便程序的维护，同时也能提高可读性</p><p><strong>原理</strong></p><ul><li>在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量</li><li>这样做的好处是让使用常量的程序执行性能与直接使用字面量是一样的</li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举是java中的一种特殊类型</p><p>为了做信息的标志和信息的分类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Srason</span>&#123;<br>    SPRING,SUMMER,AUTUMN,WINTER;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831143049994.png" alt="image-20220831143049994"> </p><p>枚举特性：</p><ul><li>枚举类都是继承了枚举类型: java.lang.Enum</li><li>枚举都是最终类，不可以被继承</li><li>构造器的构造器都是私有的，枚举对外不能创建对象</li><li>枚举类的第一行默认都是罗列枚举对象的名称的</li></ul><p>使用场景：</p><p>做信息标志和信息分类</p><p>代码可读性好</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract 是抽象的意思，可以修饰类，也可以修饰方法</p><p>注意：</p><p><strong>抽象方法只有方法签名，不能声明方法体；</strong></p><p><strong>一个类中如果定义了抽象方法，这个类必须声明成抽象类，否则报错。</strong></p><p><strong>作用：</strong></p><ul><li>作为父类，用来被继承</li></ul><p>如果一个类继承了抽象类，那么这个类就必须重写完抽象类的全部抽象方法。</p><p>否则这个类必须定义为抽象类。</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831144848383.png" alt="image-20220831144848383"></p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>类有的成员（成员变量，方法，构造器）抽象类都有</li><li>抽象类不一定有抽象方法，但是有抽象方法的类一定是抽象类</li><li>一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类必须定义成抽象类</li><li>不能用abstract修饰变量，代码块，构造器</li></ul><p><strong>最重要特征：得到了抽象方法，失去了创建对象的能力（有得有失）</strong></p><h3 id="final和abstract是什么关系？"><a href="#final和abstract是什么关系？" class="headerlink" title="final和abstract是什么关系？"></a>final和abstract是什么关系？</h3><ul><li>互斥关系</li><li>abstract定义的抽象类作为模板让子类继承，final定义的类不能被继承</li><li>抽象方法定义通用功能让子类重写， final定义的方法子类不能重写</li></ul><h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>使用场景说明：当系统中出现一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候</p><p>实现步骤：</p><ul><li>把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码</li><li>模板方法中不能决定的功能定义成抽象方法让具体的子类去实现</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831151743558.png" alt="image-20220831151743558"></p><p><strong>模板方法解决了什么问题</strong>？****</p><ul><li>提高了代码复用性</li><li>模板方法已经定义了通用结构，模板方法不能确定的部分定义成抽象方法，交给子类实现，因此，使用者只需要关心自己需要实现的功能即可。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口格式如下：</p><p>体现了一种规范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">demo</span>&#123;<br>    <span class="hljs-comment">//jdk1.8之前，接口中智能有抽象方法和常量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现：</p><p>接口是用来被实现implements的，实现接口的类称为实现类。</p><p>接口可以被单实现，也可以被类多实现</p><p>一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类</p><ul><li>类和类：单继承</li><li>接口与接口可以多继承</li><li>一个类可以实现多个接口</li></ul><h3 id="jdk8开始新增的接口方法"><a href="#jdk8开始新增的接口方法" class="headerlink" title="jdk8开始新增的接口方法"></a>jdk8开始新增的接口方法</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831153454957.png" alt="image-20220831153454957"></p><p>新增了哪些方法？</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831154204057.png" alt="image-20220831154204057"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同类型的对象，执行同一个<strong>行为</strong>，会表现出不同的行为特征</p><p>常见形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">父类型 对象名称 = <span class="hljs-keyword">new</span> 子类构造器;<br>接口 对象名称 = <span class="hljs-keyword">new</span> 实现类构造器;<br><br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831164334376.png" alt="image-20220831164334376"></p><p><strong>多态中成员访问的特点</strong></p><ul><li>方法调用：编译看左边，运行看右边</li><li>变量调用：编译看左边，运行也看左边</li></ul><p>多态的前提</p><ul><li>有继承&#x2F;实现 关系；有父类引用指向子类对象；有方法重写</li></ul><h3 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h3><ul><li>在多态模式下，右边对象可以实现解耦合，便于扩展和维护</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831164818310.png" alt="image-20220831164818310"></p><ul><li>定义方法的时候，使用父类型作为参数，该方法可以接收父类的一切子类对象，体现出多态的扩展性与遍历</li></ul><h3 id="多态下回产生的问题"><a href="#多态下回产生的问题" class="headerlink" title="多态下回产生的问题"></a>多态下回产生的问题</h3><ul><li>多态下不能使用子类的独有功能</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>自动类型转换（从子到父）：子类对象赋值给父亲类型的变量指向</p><p>强制类型转换（从父到子）：</p><ul><li>此时必须进行强制类型转换：子类 对象变量 &#x3D; （子类）父亲类型的变量</li><li>作用： 可以解决多态下的劣势，可以实现调用子类独有的功能</li><li>注意：如果转换后的类型和对象真实类型不是同一种类型，那么在转换的时候就会出现ClassCastException</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220831165625586.png" alt="image-20220831165625586"></p><p><strong>Java建议强转前使用instanceof判断当前对象的真实类型，再进行强转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><span class="hljs-type">Animal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><span class="hljs-keyword">if</span> (a1 <span class="hljs-keyword">instanceof</span> a2)&#123;<br>    System.out.println(<span class="hljs-string">&quot;类型相同&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内部类的使用场景</strong></p><ul><li>当一个事务的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。</li><li>内部类通常可以方便访问外部类的成员，包括私有的成员</li><li>内部类提供了更好的封装性，内部类本身就可以使用private protected等修饰，封装性可以做更多的控制</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>静态内部类</li></ul><p>有static修饰，属于外部类本身</p><p>特点与使用与普通类是一样的，类有的成分它都有</p><p>可以直接访问外部类的静态成员，不能直接访问外部类的实例成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>静态内部类创建对象的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br></code></pre></td></tr></table></figure><ul><li>成员内部类</li></ul><p>无static修饰，属于外部类对象</p><p>public class Outer{<br>    public  class Inner{}<br>}</p><p><strong>jak16 之前，成员内部类中不能定义静态成员，jdk16之后也可以定义静态成员了</strong></p><p>成员内部类的创建方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220901105853406.png" alt="image-20220901105853406"></p><p>注意：在成员内部类中访问所在外部类对象，格式：外部类名.this</p><ul><li><p>局部内部类(鸡肋语法，了解)</p></li><li><p><strong>匿名内部类{重点}</strong></p></li></ul><p>本质上是没有名字的局部内部类没有名字的内部类，定义在方法中、代码块中等</p><p>作用：为了方便创建类对象，最终为了简化代码编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类|抽象名|或类接口名()&#123;<br>    重写方法；<br>&#125;<br><br><span class="hljs-type">Employee</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>（）&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br>a.work();<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>没有名字的内部类</li><li>匿名内部类写出来就会产生一个匿名内部类对象</li><li>匿名内部类的对象类型就相当于当前new的那个的类型的子类类型</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902184243148.png" alt="image-20220902184243148"></p><p>匿名内部类可以作为方法的实际参数进行传输</p><p>- </p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>Object类的作用：</p><p>一个类要么默认继承了Object类，要么间接继承了Object类，是java中的祖宗类.</p><p>Object类的方法是一切子类都可以直接使用的，所以我们要学习Object类的方法</p><h3 id="Object类常用方法"><a href="#Object类常用方法" class="headerlink" title="Object类常用方法"></a>Object类常用方法</h3><p><strong>toString() 默认返回当前对象在堆内存中的地址信息，类的全限名@内存地址</strong></p><p>equals() 默认比较当前对象与另一个对象的地址是否相同，相同返回true，不同返回false</p><p>比较两个对象地址是否相同，使用&#x3D;&#x3D;也可以</p><h4 id="重写toString方法"><a href="#重写toString方法" class="headerlink" title="重写toString方法"></a>重写toString方法</h4><p>重写toString可以理解为时兑现打印输出时候的一种格式化</p><h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><ul><li>直接比较两个对象地址是否可以使用 &#x3D;&#x3D; 替代 equals</li><li>父类equals方法存在的意义就是为了被子类重写，以便子类自己来定制比较规则。</li></ul><h3 id="Objects概述"><a href="#Objects概述" class="headerlink" title="Objects概述"></a>Objects概述</h3><p>Objects类与Object还是继承关系，Objects是从jdk1.7之后才有的</p><h4 id="对象进行内容比较的时候建议使用Objects里的equals方法"><a href="#对象进行内容比较的时候建议使用Objects里的equals方法" class="headerlink" title="对象进行内容比较的时候建议使用Objects里的equals方法"></a>对象进行内容比较的时候建议使用Objects里的equals方法</h4><p>官方在进行字符串比较的时候，没有对象自己的equals方法，而是选择了Objects的equals方法来比较两个对象。</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902220736821.png" alt="image-20220902220736821"></p><p><strong>注意</strong>：****</p><p>Objects的equals方法比较结果是一样的，<strong>但是更加安全。</strong></p><p>底层会先进行非空判断，从而可以避免空指针异常。</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902221615061.png" alt="image-20220902221615061"></p><h4 id="Objects中isNull-方法"><a href="#Objects中isNull-方法" class="headerlink" title="Objects中isNull()方法"></a>Objects中isNull()方法</h4><p>Objects.isNull() 和  &#x3D;&#x3D; null 没有区别</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><ul><li>StringBuilder是一个可变的字符串类，可以把它看做是对象容器</li><li>作用：提高字符串效率，如拼接，修改</li></ul><p>构造器</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902222107775.png" alt="image-20220902222107775"></p><p>传统的String拼接字符串</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902223123787.png" alt="image-20220902223123787"></p><ol><li>s1首先在常量池里创建b</li><li>s2的时候，先在常量池创建b ，然后new StringBuilder 拼接 “ab” 然后将StringBuilder转成String类型。</li></ol><p><strong>String 一个加号，堆内存中要产生两个对象。</strong></p><p>而StringBuilder在拼接过程中只产生一个对象</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902223447906.png" alt="image-20220902223447906"></p><ul><li>String：内容不可变，拼接字符串效率差</li><li>StringBuilder 内容可变，拼接字符串性能好，代码优雅</li></ul><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>包含基本数字运算方法，Math没有公开的构造器。</p><p>工具类</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902224108800.png" alt="image-20220902224108800"></p><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>不能被实例化</p><p>全部是静态方法</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902225335271.png" alt="image-20220902225335271"></p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>用于解决浮点型运算精度失真的问题。</p><p>最好不要直接调用构造器。</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220902225630406.png" alt="image-20220902225630406"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.1</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.2</span>;<br><span class="hljs-comment">//包装浮点类型称为BigDecimal</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">ba</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(a);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(b);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ba.add(bb);<br><span class="hljs-type">double</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> c.doubleValue();<span class="hljs-comment">//直接转成double类</span><br>System.out.println(c);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>BigDecimal一定要做精度运算。</p><p>除不尽的小数会报错，要添加参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a11</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">10.0</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a22</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">3.0</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c11</span> <span class="hljs-operator">=</span> a11.divide(a22,<span class="hljs-number">2</span>, RoundingMode.HALF_UP);<span class="hljs-comment">//保留两位小数，四舍五入</span><br>System.out.println(c11);<br></code></pre></td></tr></table></figure><h2 id="Date类概述"><a href="#Date类概述" class="headerlink" title="Date类概述"></a>Date类概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">time2</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>time2 += (<span class="hljs-number">60</span>*<span class="hljs-number">60</span> +<span class="hljs-number">121</span>) *<span class="hljs-number">1000</span>;<br>System.out.println(time2);<br><span class="hljs-type">Date</span> <span class="hljs-variable">d3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time2);<br>System.out.println(d3);<br></code></pre></td></tr></table></figure><h2 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h2><ul><li>可以对Date对象或时间毫秒值格式化成我们喜欢的形式</li><li>也可以把字符串的时间形式解析成日期对象</li></ul><p><img src="C:\Users\赵宪锐\AppData\Roaming\Typora\typora-user-images\image-20220903211049901.png" alt="image-20220903211049901"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SimpleDateFormat</span><br><span class="hljs-comment">//格式化</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sdf.format(d3);<br>System.out.println(rs);<br><br><span class="hljs-type">long</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> System.currentTimeMillis() + <span class="hljs-number">121</span>*<span class="hljs-number">1000</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> sdf.format(t2);<br>System.out.println(rs2);<br><br><br><span class="hljs-comment">//时间解析</span><br>        <span class="hljs-comment">//2021年08月06日 11:11:11 往后，两天14小时49分06秒后的时间是多少</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2021年08月06日 11:11:11&quot;</span>;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(data1);<br><span class="hljs-comment">//注意</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span>  <span class="hljs-operator">=</span> d.getTime() + (<span class="hljs-number">2L</span>*<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span> + <span class="hljs-number">14</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span> + <span class="hljs-number">49</span>*<span class="hljs-number">60</span> + <span class="hljs-number">6</span>) *<span class="hljs-number">1000</span>;<br><br>        System.out.println(sdf.format(time));<br></code></pre></td></tr></table></figure><p>时间戳是一个很大的数，超过了Integer的范围<strong>，如果数字不加上L</strong>，Java认为是Integer类型，可能溢出变成负数。</p><h2 id="Calendar概述"><a href="#Calendar概述" class="headerlink" title="Calendar概述"></a>Calendar概述</h2><ul><li>Calendar代表了系统此刻日期对应的日历对象。</li><li>Calendar是一个抽象类，不能直接创建对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拿到系统此刻日历对象</span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">ca</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>System.out.println(ca);<br><span class="hljs-comment">//获取日历信息</span><br><span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> ca.get(Calendar.YEAR);<br>System.out.println(year);<br>System.out.println(ca.get(Calendar.DAY_OF_MONTH));<span class="hljs-comment">//一个月中第几天</span><br>System.out.println(ca.get(Calendar.MONTH)+<span class="hljs-number">1</span>);<span class="hljs-comment">//第几个月</span><br><span class="hljs-comment">//......</span><br></code></pre></td></tr></table></figure><h2 id="JDK8开始新增的日期API"><a href="#JDK8开始新增的日期API" class="headerlink" title="JDK8开始新增的日期API"></a>JDK8开始新增的日期API</h2><ul><li>LocalDate 不包含具体时间的日期</li><li>LocalTime 不包含日期的时间</li><li>LocalDateTime 包含了日期及时间</li><li>Instant 代表的是时间戳</li><li>DateTimeFormatter  格式化解析</li><li>Duration  用于计算两个时间间隔</li><li>Period 用于计算两个日期间隔</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220904160056398.png" alt="image-20220904160056398"></p><p>时间运算，返回的是新的时间对象，原有的时间对象不可修改</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220904160338844.png" alt="image-20220904160338844"></p><h3 id="DateTimeFormatter-时间格式化，解析"><a href="#DateTimeFormatter-时间格式化，解析" class="headerlink" title="DateTimeFormatter 时间格式化，解析"></a>DateTimeFormatter 时间格式化，解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DateTimeFormatter</span><br><span class="hljs-comment">//格式化</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM&quot;</span>);<br>System.out.println(ldt.format(dtf));<br>System.out.println(dtf.format(ldt));<br><br><br><span class="hljs-comment">//解析</span><br><br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf1</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt1</span> <span class="hljs-operator">=</span> LocalDateTime.parse(<span class="hljs-string">&quot;2019-11-11 11:11:11&quot;</span>,dtf1);<br>System.out.println(ldt1);<br></code></pre></td></tr></table></figure><h2 id="包装类-1"><a href="#包装类-1" class="headerlink" title="包装类"></a>包装类</h2><p>是八种基本数据类型对应的引用类型</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220904162627650.png" alt="image-20220904162627650"></p><p>为什么提供包装类</p><ul><li>java为了实现一切皆对象，为8种基本类型提供了对应的引用类型</li><li>后面的集合和泛型也只支持包装类性，不支持基本数据类型</li></ul><p><strong>自动装箱</strong></p><p>基本类型的数据和变量可以直接赋值给包装类性的变量</p><p><strong>自动拆箱</strong></p><p>包装类型的变量可以直接赋值给基本数据类型的变量</p><p>包装类的变量值可以是null，容错率更高。</p><p>可以把基本类型的数据转换成字符串类型。</p><p>功能</p><ul><li>可以把基本数据类型转换成字符串类型  </li><li>可以把字符串类型转换成真实的数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.parseInt(<span class="hljs-string">&quot;字符串类型的整数&quot;</span>);<br>Integer.valueof(<span class="hljs-string">&quot;字符串类型&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>可以用一些规定的字符来指定规则，用来校验数据格式的合法性</p><p> <img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220904205704366.png" alt="image-20220904205704366"></p><p>校验手机号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">phone.match(<span class="hljs-string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>校验邮箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;\\.([a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="正则表达式在字符串方法中的使用"><a href="#正则表达式在字符串方法中的使用" class="headerlink" title="正则表达式在字符串方法中的使用"></a>正则表达式在字符串方法中的使用</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220904210228262.png" alt="image-20220904210228262"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分割</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;笑哭fdsfsdf找点事jdfkslfj过儿&quot;</span>;<br>String[] arr  = name.split(<span class="hljs-string">&quot;\\w+&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<br>    System.out.println(arr[i]);<br>&#125;<br><br><span class="hljs-comment">//替换</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name2</span> <span class="hljs-operator">=</span> name.replaceAll(<span class="hljs-string">&quot;\\w+&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>System.out.println(name2);<br></code></pre></td></tr></table></figure><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] arr = &#123;<span class="hljs-number">55</span>,<span class="hljs-number">32</span>,<span class="hljs-number">444</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">34</span>,<span class="hljs-number">45</span>&#125;;<br><br><span class="hljs-comment">//Arrays toString 打印数组</span><br>System.out.println(Arrays.toString(arr));<br><br><span class="hljs-comment">//自动对数组进行排序</span><br>Arrays.sort(arr);<br>System.out.println(Arrays.toString(arr));<br><br><span class="hljs-comment">//二分搜索</span><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(arr,<span class="hljs-number">55</span>);<br>System.out.println(index);<br><span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> Arrays.binarySearch(arr,<span class="hljs-number">22</span>);<br>System.out.println(index2);<br></code></pre></td></tr></table></figure><h3 id="自定义排序规则-Comparator"><a href="#自定义排序规则-Comparator" class="headerlink" title="自定义排序规则 Comparator"></a>自定义排序规则 Comparator</h3><p>public static void sort(类型[] a) 对数组进行默认升序排序</p><p>public static <T> void sort(类型[] a, Comparator&lt;? super T&gt;) 使用比较器对象自定义排序</p><p>升序排序：</p><p>如果认为左边数据大于右边数据，返回正整数</p><p>如果认为左边数据小于右边数据，返回负整数</p><p>如果认为左边数据等于右边数据，返回0</p><p>降序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">        Integer [] ages = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">42</span>,<span class="hljs-number">112</span>,<span class="hljs-number">4</span>,<span class="hljs-number">56</span>,<span class="hljs-number">3</span>,<span class="hljs-number">25</span>,<span class="hljs-number">65</span>,<span class="hljs-number">87</span>&#125;;<br>        <span class="hljs-comment">//参数一是被排序的数组，必须是引用类型数组</span><br>        <span class="hljs-comment">//参数二是匿名内部类对象，代表了一个比较器对象</span><br>        Arrays.sort(ages, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br><span class="hljs-comment">//                if (o1 &gt; o2)&#123;</span><br><span class="hljs-comment">//                    return 1;</span><br><span class="hljs-comment">//                &#125;else if (o1 &lt; o2) &#123;</span><br><span class="hljs-comment">//                    return -1;</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                return 0;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                return o1-o2; //升序</span><br>                <span class="hljs-keyword">return</span> o2-o1; <span class="hljs-comment">//降序</span><br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220904213808156.png" alt="image-20220904213808156"></p><h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><ul><li>选择排序</li><li>二分查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//按位右移，(R-L) &gt;&gt; 1相当于除以2</span><br>middleindex = L + ((R-L) &gt;&gt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="Lambda概述"><a href="#Lambda概述" class="headerlink" title="Lambda概述"></a><strong>Lambda概述</strong></h2><ul><li>简化函数式接口的匿名内部类的写法</li></ul><p>Lambda表达式是jdk 8 开始后的一种新的语法形式</p><p>简化匿名内部类的代码写法</p><p>简化格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(匿名内部类被重写方法的形参列表) -&gt; &#123;<br>    被重写方法大的方法体代码。<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：Lambds表达式只能简化函数式接口的匿名内部类的写法形式</p><h3 id="函数式接口？"><a href="#函数式接口？" class="headerlink" title="函数式接口？"></a>函数式接口？</h3><p><strong>首先必须是接口，其次接口中有且仅有一个抽象方法的形式。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">    System.out.println(<span class="hljs-string">&quot;===============&quot;</span>);<br>    <span class="hljs-comment">//Lambda匿名内部类</span><br>    go(()-&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;老师昂&quot;</span>);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Swiming s)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;kaishi &quot;</span>);<br>    s.swim();<br>    System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="简化comparator接口的匿名形式"><a href="#简化comparator接口的匿名形式" class="headerlink" title="简化comparator接口的匿名形式"></a>简化comparator接口的匿名形式</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220905131847678.png" alt="image-20220905131847678"></p><h3 id="省略写法"><a href="#省略写法" class="headerlink" title="省略写法"></a>省略写法</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220905132558514.png" alt="image-20220905132558514"></p><h2 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h2><p>集合和数组都是容器</p><ul><li>List和Set都是继承自Collection接口。都是用来存储一组相同类型元素</li></ul><p>数组定义完成后，类型确定，长度固定。数组可以存储基本类型也可以存储引用类型。</p><p>在进行增删数据操作的时候，数组不合适，增删数据都需要放弃原有的数组或移位。</p><p>特点：</p><ul><li>集合大小不固定，启动后可以动态变化，类型也可以选择不固定</li><li>集合非常适合增删改查</li><li>集合中只能存储引用类型数据，如果要存储基本类型的数据，可以使用包装类。</li></ul><pre><code class=" mermaid">graph LR;集合---&gt;Collection;集合---&gt;Map</code></pre><ul><li>collection单列集合，每个元素只包含一个值</li><li>Map双列集合，每个元素包含两个值（键值对）</li></ul><pre><code class=" mermaid">graph LR;Collection ---&gt; List;Collection ---&gt; Set;List ---&gt; ArrayList;List ---&gt; LinkList;Set ---&gt; HashSet;Set ---&gt; TreeSet;HashSet --&gt; LinkdHashSet;</code></pre><h3 id="Collection集合特点"><a href="#Collection集合特点" class="headerlink" title="Collection集合特点"></a>Collection集合特点</h3><p>List系列集合：添加的元素是有序的可重复的，有索引</p><p>Set系列集合：添加元素是无须的，不重复，无索引</p><p>​HashSet 无序，不重复，无索引</p><p>​LinkHashSet 有序，不重复，无索引</p><p>​    TreeSet 按照大小默认升序排序，不重复，无索引</p><h3 id="集合对泛型的支持"><a href="#集合对泛型的支持" class="headerlink" title="集合对泛型的支持"></a>集合对泛型的支持</h3><p>集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//对于泛型的支持</span><br>Collection&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>Collection&lt;String&gt; lists2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//jdk1.7之后，泛型类型申可以省略不写</span><br></code></pre></td></tr></table></figure><p>集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象</p><h3 id="Collection集合常用API"><a href="#Collection集合常用API" class="headerlink" title="Collection集合常用API"></a>Collection集合常用API</h3><p>Collection是单列结合的祖宗接口，它的功能是全部单列结合都可以继承使用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//list.clear();//清空</span><br>System.out.println(list.isEmpty());<span class="hljs-comment">//集合是否为空</span><br>System.out.println(list.size());<br>System.out.println(list.contains(<span class="hljs-string">&quot;java&quot;</span>));<span class="hljs-comment">//是否包含java</span><br><br>list.remove(<span class="hljs-string">&quot;java&quot;</span>);<span class="hljs-comment">//删除元素值</span><br><br>Object [] arrs = list.toArray();<span class="hljs-comment">//转数组</span><br><br>Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list2.add(<span class="hljs-string">&quot;java&quot;</span>);<br><br>list.addAll(list2);<span class="hljs-comment">//两个集合合并</span><br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器在java中代表的是iterator 迭代器是结合专用的遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代器</span><br>Iterator&lt;String&gt; it = list.iterator();<br>System.out.println(it.next());<br></code></pre></td></tr></table></figure><ul><li>迭代器默认位置是索引0</li><li>如果迭代器取元素越界，会出现NoSuchElementException异常</li></ul><h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><ul><li>增强for循环，既可以遍历集合也可以遍历数组</li><li>jdk5之后出现， 内部原理是一个iterator迭代器，遍历集合相当于是迭代器的简化写法</li><li>实现iterator接口的类才可以使用迭代器和增强for，COllection接口已经实现了iterator接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr)&#123;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220906110458646.png" alt="image-20220906110458646"></p><h4 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h4><h4 id="使用stream迭代"><a href="#使用stream迭代" class="headerlink" title="使用stream迭代"></a>使用stream迭代</h4><h3 id="Lambda表达式遍历"><a href="#Lambda表达式遍历" class="headerlink" title="Lambda表达式遍历"></a>Lambda表达式遍历</h3><ul><li>得益于jdk8开始的新技术lambda表达式，提供了一种更简单，更直接的遍历集合的方式</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220906111152543.png" alt="image-20220906111152543"></p><h3 id="Collection存储自定义类型对象"><a href="#Collection存储自定义类型对象" class="headerlink" title="Collection存储自定义类型对象"></a>Collection存储自定义类型对象</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220906112012271.png" alt="image-20220906112012271"></p><p>集合中存储的是元素什么信息？</p><p><strong>集合中存储的是对象的地址</strong></p><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><p>数据结构是计算机的<strong>底层存储，组织数据的方式</strong></p><p>精心选择的数据结构可以带来更高的运行或者存储效率</p><ul><li>栈： 后进先出</li><li>队列：先进先出，后进后出</li><li>数组：查询速度快（元素在内存中是连续存储的）通过地址和索引定位。 增加，删除效率低</li><li>链表：在内存中不连续，每个元素节点包含数据和下一个元素的地址。 查询慢，增删块。</li><li>二叉树：只能有一个根节点，每个节点最多支持2个直接子节点。</li></ul><p>​二叉树的度不大于2。</p><ul><li>平衡二叉树：满足查找二叉树的大小规则下，让树尽可能矮小，以提高查数据性能。</li></ul><p>​任意节点的左右两个子树高度差不超过1，任意节点左右两个子树都是一颗平衡二叉树</p><p>​基本策略是进行左旋或者右旋保持平衡</p><ul><li>红黑树：是一种自平衡的二叉查找树。  <strong>红黑树增删该查的性能都很好</strong><ul><li>每一个节点可以是红也可以是黑，红黑树不是通过高度平衡的，它的平衡是通过红黑规则进行实现的。</li></ul></li></ul><p>红黑规则：</p><ul><li>每一个节点是红色或者黑色，根节点必须是黑色</li><li>如果一个节点没有子节点或父节点，则该节点相应的指针属性为NIl，这些Nil视为叶节点，叶子节点是黑色的。</li><li>如果某一个节点是红色的，那么它的叶子节点必须是黑色（不能出现两个红色节点相连的情况）</li><li>对于每个节点，从该节点到其他所有后代节点的简单路径上，均包含数目相同的黑色节点。</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220906165313972.png" alt="image-20220906165313972"></p><h4 id="红黑树添加节点"><a href="#红黑树添加节点" class="headerlink" title="红黑树添加节点"></a>红黑树添加节点</h4><ul><li>添加的节点的颜色，可以是红色也可以是黑色</li><li>默认用红色效率高</li></ul><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>有序、可重复、有索引</p><h3 id="独有的方法"><a href="#独有的方法" class="headerlink" title="独有的方法"></a>独有的方法</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220906212203010.png" alt="image-20220906212203010"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//根据索引插入数据</span><br>list.add(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;musql&quot;</span>);<br>System.out.println(list);<br><br>System.out.println(list.get(<span class="hljs-number">3</span>));<br><span class="hljs-comment">//修改索引位置元素</span><br>System.out.println(list.set(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;orcale&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>ArrayList底层是基于数组实现的，查询快，增删相对慢</li><li>LinkedList底层是基于双链表实现的，查询慢，增删首尾元素快</li></ul><h3 id="ArrayLIst"><a href="#ArrayLIst" class="headerlink" title="ArrayLIst"></a>ArrayLIst</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220906213218424.png" alt="image-20220906213218424"></p><p>ArrayList第一次创建并添加元素的时候，在底层创建一个默认长度为10的数组。</p><p>用size记录下次插入元素的位置。</p><h3 id="LinkedList的特点"><a href="#LinkedList的特点" class="headerlink" title="LinkedList的特点"></a>LinkedList的特点</h3><p>独有方法</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220906213836966.png" alt="image-20220906213836966"></p><p>压栈出栈的一些方法。也可以实现入队出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">//压栈</span><br>stack.addFirst(<span class="hljs-string">&quot;第1颗&quot;</span>);<br>stack.addFirst(<span class="hljs-string">&quot;第2颗&quot;</span>);<br>stack.addFirst(<span class="hljs-string">&quot;第3颗&quot;</span>);<br>stack.addFirst(<span class="hljs-string">&quot;第4颗&quot;</span>);<br>stack.push(<span class="hljs-string">&quot;第5颗&quot;</span>);<br>System.out.println(stack);<br><br><span class="hljs-comment">//出栈</span><br>System.out.println(stack.removeFirst());<br>System.out.println(stack.pop());<br><br><br></code></pre></td></tr></table></figure><h2 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h2><p>迭代修改集合中的元素的时候，要使用迭代器删除当前位置元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;java&quot;</span>);<br>list.add(<span class="hljs-string">&quot;python&quot;</span>);<br>list.add(<span class="hljs-string">&quot;C&quot;</span>);<br>list.add(<span class="hljs-string">&quot;java&quot;</span>);<br><br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> it.next();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;java&quot;</span>.equals(ele))&#123;<br>        <span class="hljs-comment">//list.remove(&quot;java&quot;);</span><br>        it.remove();<span class="hljs-comment">//使用迭代器删除当前位置，保证不后移</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一边遍历，一边删除，会出bug，所以应该使用迭代器删除当前位置。</p><p>哪些遍历存在问题？</p><ul><li>迭代器遍历集合直接使用集合删除元素可能会出现</li><li>增强for循环使用集合删除元素可能会出现</li></ul><p>解决：</p><p>迭代器遍历，使用迭代器删除方法可以解决</p><p>使用for循环遍历元素不会存在这个问题。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是jdk5中引入的特性，可以在编译阶段约束数据的操作，并进行检查</p><ul><li>泛型的格式&lt;&gt; 注意：泛型只支持<strong>引用数据类型</strong></li><li>集合体系的全部接口和实现类都是支持泛型的使用的。</li></ul><p>泛型的好处：<br>统一数据类型</p><h3 id="泛型可以在很多地方进行定义"><a href="#泛型可以在很多地方进行定义" class="headerlink" title="泛型可以在很多地方进行定义"></a>泛型可以在很多地方进行定义</h3><p>类后面 —– 泛型类</p><p>方法申明上—– 泛型方法</p><p>接口后面—— 泛型接口</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul><li>定义类的同时定义了泛型的类就是泛型类</li><li>泛型类格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;T&gt;()&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>此处的泛型变量T可以随便写为任意标志，常见的如 E、T、K、V</li><li>作用：编译阶段可以指定数据类型，类似于集合的作用</li></ul><h3 id="泛型方法："><a href="#泛型方法：" class="headerlink" title="泛型方法："></a>泛型方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(T t)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>方法中可以使用泛型接受一切实际类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printA</span><span class="hljs-params">(T[] arr)</span>&#123;<br>    <span class="hljs-keyword">if</span>(arr != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;&#123;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            sb.append(arr[i]).append(i== arr.length -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> :<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(arr);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>泛型方法的作用：<br>方法中可以使用泛型接受一切实际类型的数据，方法更具有通用性。</p><h3 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h3><p>使用泛型定义的接口就是泛型接口</p><p>public interface Data<E>{}</p><p>作用： 泛型接口可以让<strong>实现类选择当前功能需要操作的数据类型</strong></p><p>泛型接口的原理：<br>实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作。</p><h3 id="泛型的通配符，上下限"><a href="#泛型的通配符，上下限" class="headerlink" title="泛型的通配符，上下限"></a>泛型的通配符，上下限</h3><ul><li>？可以在使用泛型的时候代表一切类型</li><li>E T K V 是在定义泛型的时候使用的</li></ul><p>泛型的上下限问题</p><ul><li>? entends Car  ?必须是car或者子类，泛型上限</li><li>? super Car ?必须是car或者其父类 泛型下限</li></ul><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><ul><li><p>无序：存取顺序不一致</p></li><li><p>不重复：可以去除重复</p></li><li><p>无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素</p></li><li><p>HashSet ： 无序 不重复，无索引</p></li><li><p>LinkedHashSet <strong>有序</strong>、不重复、无索引</p></li><li><p>TreeSet  <strong>可排序</strong>、不重复。无索引</p></li></ul><h3 id="HashSet底层原理："><a href="#HashSet底层原理：" class="headerlink" title="HashSet底层原理："></a>HashSet底层原理：</h3><ul><li>底层采用哈希表存储数据</li><li>哈希表是一种对于增删改查数据性能都较好的结构</li></ul><h4 id="哈希表的组成"><a href="#哈希表的组成" class="headerlink" title="哈希表的组成"></a>哈希表的组成</h4><p>jdk8之前，底层使用数组+链表组成</p><p>jdk8之后，<strong>底层采用数组+链表+红黑树组成</strong></p><p>哈希值： 是jdk根据对象的地址，按照某种规则计算出来的int型的数值</p><p>public int  hashCode（） 返回兑现的hash值</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220908221826053.png" alt="image-20220908221826053"></p><p>哈希表是一种对于增删改查都较好的数据结构</p><p><strong>jdk1.8之后开始底层结构改变</strong>，进一步提高性能</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220908222635050.png" alt="image-20220908222635050"></p><h4 id="哈希表详细流程"><a href="#哈希表详细流程" class="headerlink" title="哈希表详细流程"></a>哈希表详细流程</h4><ol><li>创建一个默认长度为16，默认加载因为0.75的数组，数组名为table</li><li>根据元素的哈希值跟数组长度计算出应该存入的位置</li><li>判断当前位置是否为null，如果是null，直接存入。如果不为null，表示有元素，调用equals比较方法的属性值，如果一样，不存。如果不一样，存入数组。</li><li>当数组存满到 16*0.75&#x3D;12时，自动扩容。每次扩容原先的两倍</li></ol><h4 id="重写hashCode和equals方法"><a href="#重写hashCode和equals方法" class="headerlink" title="重写hashCode和equals方法"></a>重写hashCode和equals方法</h4><p><strong>注意： 如果希望Set集合认为两个内容是一样的对象是重复的。必须重写hashCode和equals方法</strong></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220908223906552.png" alt="image-20220908223906552"></p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>有序、不重复、无索引</p><p>底层数据结构依然是哈希表，只是每个元素又额外多了一个双链表机制记录存储的顺序</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220908224159232.png" alt="image-20220908224159232"></p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>不重复，无索引，可排序</p><p>可以按照元素的大小默认升序排序</p><p>TreeSet的底层是基于红黑树的数据结构实现排序的，增删改查性能比较好</p><p><strong>想要使用TreeSet存储自定义对象，需要定制排序规则</strong></p><ul><li>对于数值类型，Integer Double 官方默认按照大小进行排序</li><li>对于字符串类型，默认按照首字符的编号升序排序</li><li>对于自定义类型如 Student对象，TreeSet无法直接排序</li></ul><h4 id="自定义排序规则"><a href="#自定义排序规则" class="headerlink" title="自定义排序规则"></a>自定义排序规则</h4><p>方式一：<br>让自定义类实现Comparable接口，重写里面的compareto方法制定比较规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Students</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Students&gt;&#123;<span class="hljs-comment">//注意：comparable要加泛型</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Students o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.age-o.getAge()&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>方式二：<br>TreeSet集合有参数构造器，可以设置Comparable接口对应的比较器对象，来定制比较规则</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220908225528079.png" alt="image-20220908225528079"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220911155139395.png" alt="image-20220911155139395"></p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>可变参数用在形参中可以接收多个数据</li><li>可变参数的格式：数据类型…参数名称</li></ul><p>可变参数的作用</p><ul><li>传输参数非常灵活，方便，可以不传参数，可以传输1个或者多个参数，也可以传输一个数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可变参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sun</span><span class="hljs-params">(<span class="hljs-type">int</span>...nums)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数在方法内部本质上还是一个数组</p><p>注意；</p><ul><li><p>一个形参列表中只能有一个可变参数</p></li><li><p>可变参数必须放在形参列表的后边</p></li><li></li></ul><h2 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h2><h3 id="Collections和Collection的区别："><a href="#Collections和Collection的区别：" class="headerlink" title="Collections和Collection的区别："></a>Collections和Collection的区别：</h3><p>Collection是一个集合的接口，是List和Set等集合的接口</p><p>Collections是一个包装类，包含很多集合相关操作的接口，此类不能实例化。就像一个工具类。</p><p>用来对集合操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//批量加元素</span><br>Collections.addAll(list,<span class="hljs-number">31</span>,<span class="hljs-number">44</span>,<span class="hljs-number">13</span>,<span class="hljs-number">45</span>);<br><span class="hljs-comment">//打乱</span><br>Collections.shuffle(list);<br></code></pre></td></tr></table></figure><p>Collections排序相关API</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220911162107304.png" alt="image-20220911162107304"></p><p>一般使用方式2 </p><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>是一种双列集合，每个元素包含两个数据</p><p>key value键值对</p><p>也被成为键值对集合</p><ul><li>键无序、不重复、无索引、值不做要求</li><li>键值对都可以为null</li><li>后面重复的键会覆盖前面键的值</li></ul><p>Map集合实现类的特点：</p><ul><li>HashMap 元素按照键是无序，不重复，无索引，值不做要求</li><li>LinkedHashMap 元素按照键是有序，不重复，无索引，值不做要求</li><li>TreeSet 元素按照键是排序，不重复，无索引的，值不做要求</li></ul><p>Map是双列结合的祖宗接口，它的功能是全部双列集合都可以继承使用的</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220911184755505.png" alt="image-20220911184755505"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;12&quot;</span>,<span class="hljs-number">12</span>);<br>map.put(<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-number">123</span>);<br>map.put(<span class="hljs-string">&quot;oracle&quot;</span>,<span class="hljs-number">32</span>);<br><br>System.out.println(map.isEmpty());<br>System.out.println(map.get(<span class="hljs-string">&quot;java&quot;</span>));<br>System.out.println(map.containsValue(<span class="hljs-number">12</span>));<br>Set&lt;String&gt; sets  = map.keySet(); <span class="hljs-comment">//键用set集合接收</span><br>Collection&lt;Integer&gt; col = map.values();<span class="hljs-comment">//使用collection接收value</span><br></code></pre></td></tr></table></figure><p>Map遍历方式</p><p>（1）键找值 for循环</p><p>（2） 键值对</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220911190312604.png" alt="image-20220911190312604"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();<br></code></pre></td></tr></table></figure><p>​（3）Lambda表达式</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220911190904939.png" alt="image-20220911190904939"></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>无序，不重复，无索引</p><p>Set系列集合的底层就是Map实现的，只是Set集合中的元素只要数据，不要数据而已</p><ul><li>HashMap底层是哈希表结构的</li><li>依赖hashCode方法和equal方法保证键的唯一</li><li>基于哈希表，增删改查性能比较好</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Students, String&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-type">Students</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Students</span>(<span class="hljs-string">&quot;wuyang&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;man&quot;</span>);<br><span class="hljs-type">Students</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Students</span>(<span class="hljs-string">&quot;wuyang&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;man&quot;</span>);<br><span class="hljs-type">Students</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Students</span>(<span class="hljs-string">&quot;wuyan2g&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;man&quot;</span>);<br><br>maps.put(s1,<span class="hljs-string">&quot;北京&quot;</span>);<br>maps.put(s2,<span class="hljs-string">&quot;上海&quot;</span>);<br>maps.put(s3,<span class="hljs-string">&quot;济南&quot;</span>);<br>System.out.println(maps);<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>Students类重写hashCode 和equal方法来保证了键的唯一。</p><h4 id="遍历，Map转set"><a href="#遍历，Map转set" class="headerlink" title="遍历，Map转set"></a>遍历，Map转set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();<br>System.out.println(entries);<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String,Integer&gt; entry :entries)&#123;<br>    System.out.println(entry);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>有序，不重复，无索引</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220911220427820.png" alt="image-20220911220427820"></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>由键决定特性，不重复，无索引，可排序</li><li>可排序：按照键数据的大小默认升序，只能对键进行排序</li><li>注意：TreeMap 集合一定是要排序的，可以默认排序，也可以将键按照指定规则进行排序</li><li>跟TreeSet底层原理是一样的</li></ul><p>自定义排序规则有两种：</p><p>1. </p><ol><li><strong>类实现Comparable接口，重写比较规则</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Students</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Students&gt;&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Students o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.age-o.getAge()&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>2<strong>集合自定义Comparable比较器对象，重写比较规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Students,String&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Students&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Students o1, Students o2)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<span class="hljs-comment">//升序排序，且年龄不能重复</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>如果类里面和集合里面都实现了比较器，会优先使用集合里面定义的比较器。</p><h2 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h2><p>某个班级多名学生，需要组成秋游活动，班长提供经典A，B，C，D 每个学生可以选多个景点，统计出哪个景点人数多。</p><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><ul><li>不可修改的集合</li><li>集合的数据项在创建的时候提供，并且在整个生命周期中不可变。否则报错</li><li>当集合对象被不可信的库调用的时候，不可变形式是安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List,of(<span class="hljs-string">&quot;fds&quot;</span>,<span class="hljs-string">&quot;dfs&quot;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>在java 8 中，得益于lambda表达式函数式编程，引入stream</p><ul><li>目的：简化集合和数组操作的API</li></ul><p>找出集合中姓张的且三个字的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用stream实现</span><br>list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter(s -&gt; s.length() == <span class="hljs-number">3</span>)<br>        .forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><p>得益于lambda </p><h3 id="Stream流的获取"><a href="#Stream流的获取" class="headerlink" title="Stream流的获取"></a>Stream流的获取</h3><ul><li><p>获取stream流</p><ul><li>创建一条流水线并把数据放到流水线上进行操作</li></ul></li><li><p>中间方法</p><ul><li>流水线上操作，一次操作完毕之后，还可以继续进行其他操作</li></ul></li><li><p>终结方法</p><ul><li>一个stream流只能有一个终结方法，是流水线上最后的一个操作</li></ul></li></ul><p>获取stream的方法；</p><p>1. </p><ol><li>使用collection接口中的默认方法stream生成流</li></ol><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220912143902022.png" alt="image-20220912143902022"></p><ol><li>数组获取stream流的方法</li></ol><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220912143909560.png" alt="image-20220912143909560"></p><p>集合获取Stream通过调用stream()方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Collection获取流</span><br>Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Stream&lt;String&gt; s = list.stream();<br><span class="hljs-comment">//Map获取流</span><br>Map&lt;String,Integer&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//键流</span><br>Stream&lt;String&gt; s1 = m.keySet().stream();<br><span class="hljs-comment">//值流</span><br>Stream&lt;Integer&gt; i = m.values().stream();<br><span class="hljs-comment">//键值对流</span><br>Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValuezStream = m.entrySet().stream();<br></code></pre></td></tr></table></figure><p>数组获取stream方式，通过两种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String [] a = &#123;<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;fs&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>&#125;;<br>Stream&lt;String&gt; nameStream = Arrays.stream(a);<span class="hljs-comment">//1</span><br>Stream&lt;String&gt; nameStream2 =Stream.of(a);<span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h3 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h3><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220912145717879.png" alt="image-20220912145717879"></p><ul><li>中间方法也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程</li></ul><p>终结方法后流不可以继续使用，非终结方法会返回新的流，支持链式编程</p><h3 id="收集Stream流"><a href="#收集Stream流" class="headerlink" title="收集Stream流"></a>收集Stream流</h3><p>收集Stream流的含义：就是把stream流操作后的结果转回到集合或者数组中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; str =list.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>));<br>List&lt;String&gt; li = str.collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p>注意：流只能使用一次。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>异常是程序在编译或者执行过程中可能出现的问题，注意：语法错误不算在异常体系中</li><li>比如：数组索引越界，空指针异常，日期格式化异常等</li></ul><h3 id="为什么要学习异常"><a href="#为什么要学习异常" class="headerlink" title="为什么要学习异常"></a>为什么要学习异常</h3><ul><li>异常一旦出现，如果没有提处理，程序就会退出JVM虚拟机而终止</li><li>研究异常并且避免异常，然后提前处理异常，体现的就是程序的安全，健壮性</li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220912165936490.png" alt="image-20220912165936490"></p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220912170030879.png" alt="image-20220912170030879"></p><h3 id="常见运行时异常"><a href="#常见运行时异常" class="headerlink" title="常见运行时异常"></a>常见运行时异常</h3><p>RuntimeException 或其子类。编译不报错，运行可能会出现错误</p><p><strong>运行时异常：一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误。</strong></p><ul><li>数组越界引起异常： ArrayIndexOutofBoundsException</li><li>空指针异常 NullPointerException</li><li>数字操作异常 ArithmeticException</li><li>类型转换异常：ClassCastException</li><li>数字转换异常 NumberFormatException</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">//ArrayIndexOutofBoundsException  数组越界</span><br><span class="hljs-comment">//        int[] arr = &#123;1,2,3&#125;;</span><br><span class="hljs-comment">//        System.out.println(arr[4]);</span><br><br>        <span class="hljs-comment">//空指针异常</span><br><span class="hljs-comment">//        String s = null;</span><br><span class="hljs-comment">//        System.out.println(s.length());</span><br><br>        <span class="hljs-comment">//数字操作异常ArithmeticException</span><br><span class="hljs-comment">//        int c = 10/0;</span><br><br>        <span class="hljs-comment">//类型转换异常 ClassCastException</span><br><span class="hljs-comment">//        Object o = 23;</span><br><span class="hljs-comment">//        String s = (String) o;</span><br><br>        <span class="hljs-comment">//NumberFormatException 数字转换异常</span><br>        String number= <span class="hljs-string">&quot;123fsd&quot;</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> Integer.valueOf(number);<br>        System.out.println(it);<br></code></pre></td></tr></table></figure><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>编译阶段就报错</p><h3 id="异常默认异常处理机制"><a href="#异常默认异常处理机制" class="headerlink" title="异常默认异常处理机制"></a>异常默认异常处理机制</h3><ol><li>默认会在出现异常的代码那里自动创建一个异常对象</li><li>异常会从方法中出现的点这里抛出给调用者，调用者最终会抛出给JVM虚拟机</li><li>虚拟机接收到异常对象之后，先在控制台直接输出异常栈信息数据</li><li>直接从当前执行的异常点干掉当前程序</li><li>程序死亡</li></ol><h3 id="编译-时异常处理形式"><a href="#编译-时异常处理形式" class="headerlink" title="编译 时异常处理形式"></a>编译 时异常处理形式</h3><p>1出现异常直接抛出给调用者，调用者也直接抛出  throws</p><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220912174215652.png" alt="image-20220912174215652"></p><p>2  try catch </p><ul><li>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理</li><li>这种方法还可以，发生异常的方法自己独立完成异常的处理，<strong>程序可以继续往下进行</strong></li></ul><p><img src="https://ricky1999.oss-cn-beijing.aliyuncs.com/imgs/image-20220913112020172.png" alt="image-20220913112020172"></p><p>3 前两者结合</p><ul><li>方法直接将异常通过throws抛出去给调用者</li><li>调用者收到异常后直接捕获处理</li></ul><p>总结：<br>在开发中按照规范来说第三种方式是最好的，底层的异常抛出给最外层，最外层集中捕获处理</p><ul><li>实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式都可以</li></ul><h3 id="运行时异常处理形式"><a href="#运行时异常处理形式" class="headerlink" title="运行时异常处理形式"></a>运行时异常处理形式</h3><p>编译阶段不会报错。运行时才会报错</p><p>按照规范建议还是处理：建议在最外层调用处集中捕获即可</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>java无法为这个世界全部问题提供异常类</p><p>好处：<br>可以使用异常机制管理业务问题</p><h3 id="自定义编译时异常"><a href="#自定义编译时异常" class="headerlink" title="自定义编译时异常"></a>自定义编译时异常</h3><ul><li>定义一个异常类继承Exception</li><li>重写构造器</li><li>在出现异常的地方用throw new 定义对象抛出</li></ul><p>作用：编译时异常是编译阶段就报错，<strong>提醒更加强烈</strong>，一定要处理</p><h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>throw在方法内部直接创建一个异常对象，并从此点抛出</p><p>throws 在方法中声明，抛出方法内部的异常。</p><h3 id="自定义运行时异常"><a href="#自定义运行时异常" class="headerlink" title="自定义运行时异常"></a>自定义运行时异常</h3><ul><li>定义一个异常类继承RuntimeException </li><li>重写构造器</li><li>在出席县异常的地方用throw new 自定义对象抛出</li></ul><p>作用：提醒不强烈，编译阶段不报错，运行时才可能出现</p><h1 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h1><p>请见下篇！！！</p>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/13/hello-world/"/>
    <url>/2022/11/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">标签</p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Hello Word</category>
      
      <category>Begin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello Word</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
